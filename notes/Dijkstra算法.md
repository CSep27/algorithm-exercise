# Dijkstra 算法

## 无向图

资料：[一篇文章讲透 Dijkstra 最短路径算法](https://www.cnblogs.com/goldsunshine/p/12978305.html)

这篇资料中的图是无向的

### 问题描述

![Dijkstra-1](./images/Dijkstra-1.png)

图中记录了直接相连的每个点之间的距离，以 A 为起点，计算到其他点的最短路径。

1. 与 A 直接相连的，直接记录距离数据，否则记为 ∞
2. 任何点到自身为 0
3. 构建一个最短距离数组，初始记录每个点到 A 点的距离。
4. 从最短距离数组中，每次选择一个最近的点，将其作为下一个点，然后重新计算从起始点经过该点到其他所有点的距离，更新最短距离数据。已经选取过的点就是确定了最短路径的点，不再参与下一次计算。

### 分析过程

**最短路径**
| 起点 | 终点 | 最短路径 | 最短距离 |
|------|------|----------|:---------|
| A | D | A-D | 4 |
| | B | A-D-B | 6 |
| | E | A-D-E | 10 |
| | C | A-D-E-C | 11 |
| | F | A-D-E-C-F | 16 |

1. 最短距离表格初始状态，记录各点到 A 点的距离

   | A   | B   | C   | D   | E   | F   |
   | --- | --- | --- | :-- | :-- | :-- |
   | 0   | 10  | ∞   | 4   | ∞   | ∞   |

   已选列表：S = ['A']
   未选列表：U = ['B','C','D','E','F']

1. 与 A 直连的是 B 和 D 点，算出距离 D 更短，选择 D 作为下一个点，计算 A-D-其他点 的距离。然后和上一步的表格比较，如果距离更小，值更新（用下划线标识）。

   1. B 点 更新为 6，当前最短路径是 A-D-B
   2. C、E 更新

   | A   | B        | C         | D   | E         | F   |
   | --- | -------- | --------- | :-- | :-------- | :-- |
   | 0   | 10       | ∞         | 4   | ∞         | ∞   |
   | 0   | <u>6</u> | <u>19</u> | 4   | <u>10</u> | ∞   |

   已选列表：S = ['A','D']
   未选列表：U = ['B','C','E','F']
   A-D 最短路径确认，更新到上面最短路径表格

1. 在未选列表中，剩下最小距离为 B 点。按照 A-D-B-其他点 方案，更新到未选列表中其他点的距离。

   1. 到 C 点 更新为 14
   2. 到 E 点 12，更大，所以不更新，当前最短路径仍然是 A-D-E

   | A   | B   | C         | D   | E         | F   |
   | --- | --- | --------- | :-- | :-------- | :-- |
   | 0   | 6   | 19        | 4   | 10        | ∞   |
   | 0   | 6   | <u>14</u> | 4   | <u>10</u> | ∞   |

   与 B 点直接相连的三个点为 C、D、E，其中在未选列表中，并且距离最短的是 E 点，下一个点为 E 点

   已选列表：S = ['A','D','B']
   未选列表：U = ['C','E','F']
   A-B 最短路径确认，更新到上面最短路径表格最短路径表格

1. 在未选列表中，剩下最小距离为 E 点。按照 A-D-B-E-其他点 方案，更新到未选列表中其他点的距离。

   1. C 点 更新为 11
   2. F 点 更新为 22

   | A   | B   | C         | D   | E   | F         |
   | --- | --- | --------- | :-- | :-- | :-------- |
   | 0   | 6   | 14        | 4   | 10  | ∞         |
   | 0   | 6   | <u>11</u> | 4   | 10  | <u>22</u> |

   与 E 相连的 D、B、C、F 中，其中在未选列表中，并且距离最短的是 C 点，下一个点选择 C 点

   已选列表：S = ['A','D','B','E']
   未选列表：U = ['C','F']
   A-E 最短路径确认，更新到上面最短路径表格

1. 在未选列表中，剩下最小距离为 E 点。按照 A-D-E-C-其他点，更新

   1. F 点 更新为 16

   | A   | B   | C   | D   | E   | F         |
   | --- | --- | --- | :-- | :-- | :-------- |
   | 0   | 6   | 14  | 4   | 10  | ∞         |
   | 0   | 6   | 11  | 4   | 10  | <u>16</u> |

   与 E 相连的只剩最后一个点 F 了，此时的距离就是最终结果了  
   已选列表：S = ['A','D','B','E','C','F']
   A-C、A-F 最短路径确认，更新到上面最短路径表格

### 代码实现

#### 数据结构

![Dijkstra-2](./images/Dijkstra-2.png)

如图，可以使用二维数组表示各点之间的距离

```js
const matrix = [
  [0, 10, Infinity, 4, Infinity, Infinity],
  [10, 0, 8, 2, 6, Infinity],
  [Infinity, 8, 10, 15, 1, 5],
  [4, 2, 15, 0, 6, Infinity],
  [Infinity, 6, 1, 6, 0, 12],
  [Infinity, Infinity, 5, Infinity, 12, 0],
];
```

记录最短距离的数组 distance，初始值就等于 matrix[0]

已经确定最短距离的点不参与后续计算。在二维数组中，索引就对应着每个点，可以再用一个和 matrix 相同长度的数组 nodes，每个对应位置的布尔值表示当前位置的点是否已经被计算过。同时循环结束的条件就是 node 数组中不再包含为 false 的值。

#### 代码思路

按照前述分析，不断重复的过程是：

1. 获取最短距离的数组 distance 中值最小的点（已经计算过的点，不再参与最小值计算），值记为 minValue，对应索引记为 minValueIndex
2. 比较 distance 数组中原来每个位置的值，和新的经过最短路径的算出来的路径值进行比较，如果新值更小，则更新到数组中。

   - minValueIndex 点，到达各点的距离，就是`matrix[minValueIndex]`数组中记录的值
   - 经过最短路径的值，就是`distance[minValueIndex] + matrix[minValueIndex][j]`

代码：./code/dijkstra.js

## 有向无环图

### 问题描述

某通信网络中有一个网络节点。用 1~n 进行标识。网络通过一个**有向无环图**表示。其中图的边的值表示节点之间的消息传递时延。现给定相连节点之间的时延列表。其中 u 表示原节点。v 表示目的节点。w 表示 u 和 v 之间的消息传递时延。请计算给定源节点到目的节点的最小传输时延。如果目的节点不可达返回复-1。
注：n 的取值范围为 1~100。时延列表的长度不超过 6000，且 1<=u,v<=n,0<=w<=1000。

![2-5有向无环图](./images/2-5有向无环图.png)

### 分析过程

按照上一种解法，构造二维数组，如下。测试代码：code/dijkstra-1.js。同样可以得到结果。

```js
const matrix = [
  [0, 10, Infinity, 4, Infinity, Infinity],
  [Infinity, 0, 2, 2, 6, Infinity],
  [Infinity, Infinity, 0, Infinity, 1, 3],
  [Infinity, Infinity, 15, 0, 6, Infinity],
  [Infinity, Infinity, Infinity, Infinity, 0, 12],
  [Infinity, Infinity, Infinity, Infinity, Infinity, 0],
];
```

题目示例数据：

![2-5有向无环图-1](./images/2-5有向无环图-1.png)

答案中的解法，先将输入的数据处理成：

```js
const arr = [
  ["1", "2", 11],
  ["2", "3", 13],
  ["1", "3", 50],
];
```

再将 arr 处理为对象。元素 1 可以连接到 2 和 3，元素 2 可以连接到 3，元素 3 没有指向其他元素

```js
const obj = {
  1: [
    ["2", 11],
    ["3", 50],
  ],
  2: [["3", 13]],
};
```

由于数据结构不同，代码不同，思想都是一样，每次取最短路径。

1. distance 存储距离，长度为网络节点个数+1。由于源从 1 开始，索引 0 位置不用，为了方便索引对应
2. 从起始点 startIndex 开始，获取到`obj[startIndex]`数组，更新 distance
3. 与 startIndex 连接的点，都要尝试走一下，needCheckArr 用于存储还没检查过的点
4. needCheckArr 数组值有更新的情况下，需要根据 distance[i]进行排序，取最短路径，作为下一个 startIndex
5. 在循环`obj[startIndex]`数组，更新 distance 时，需要将到 v 的当前最短路径`distance[v]`和经过 startIndex 的新路径（distance[startIndex] + w）进行比较。若新路径更小，则更新 distance。
6. 循环结束的条件是 needCheckArr 中没有值了，也就意味着当前点没有到达其他点的路径。

代码：exercise/level-2/5.最小传输时延-2.js

# 问题

【待完成】

- [图论及其应用](https://book.sciencereading.cn/shop/book/Booksimple/show.do?id=B3A8832D6E3794DB2B2048974EBCCFC0A000)
- [图论相关概念](https://oi-wiki.org/graph/concept/)

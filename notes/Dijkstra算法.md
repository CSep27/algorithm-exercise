# Dijkstra 算法

资料：[一篇文章讲透 Dijkstra 最短路径算法](https://www.cnblogs.com/goldsunshine/p/12978305.html)

## 问题描述

![Dijkstra-1](./images/Dijkstra-1.png)

图中记录了直接相连的每个点之间的距离，以 A 为起点，计算到其他点的最短路径。

1. 与 A 直接相连的，直接记录距离数据，否则记为 ∞
2. 任何点到自身为 0
3. 构建一个最短距离数组，初始记录每个点到 A 点的距离。
4. 从最短距离数组中，每次选择一个最近的点，将其作为下一个点，然后重新计算从起始点经过该点到其他所有点的距离，更新最短距离数据。已经选取过的点就是确定了最短路径的点，不再参与下一次计算。

## 分析过程

**最短路径**
| 起点 | 终点 | 最短路径 | 最短距离 |
|------|------|----------|:---------|
| A | D | A-D | 4 |
| | B | A-D-B | 6 |
| | E | A-D-E | 10 |
| | C | A-D-E-C | 11 |
| | F | A-D-E-C-F | 16 |

1. 最短距离表格初始状态，记录各点到 A 点的距离

   | A   | B   | C   | D   | E   | F   |
   | --- | --- | --- | :-- | :-- | :-- |
   | 0   | 10  | ∞   | 4   | ∞   | ∞   |

   已选列表：S = ['A']
   未选列表：U = ['B','C','D','E','F']

1. 与 A 直连的是 B 和 D 点，算出距离 D 更短，选择 D 作为下一个点，计算 A-D-其他点 的距离。然后和上一步的表格比较，如果距离更小，值更新（用下划线标识）。

   1. B 点 更新为 6，当前最短路径是 A-D-B
   2. C、E 更新

   | A   | B        | C         | D   | E         | F   |
   | --- | -------- | --------- | :-- | :-------- | :-- |
   | 0   | 10       | ∞         | 4   | ∞         | ∞   |
   | 0   | <u>6</u> | <u>19</u> | 4   | <u>10</u> | ∞   |

   已选列表：S = ['A','D']
   未选列表：U = ['B','C','E','F']
   A-D 最短路径确认，更新到上面最短路径表格

1. 在未选列表中，剩下最小距离为 B 点。按照 A-D-B-其他点 方案，更新到未选列表中其他点的距离。

   1. 到 C 点 更新为 14
   2. 到 E 点 12，更大，所以不更新，当前最短路径仍然是 A-D-E

   | A   | B   | C         | D   | E         | F   |
   | --- | --- | --------- | :-- | :-------- | :-- |
   | 0   | 6   | 19        | 4   | 10        | ∞   |
   | 0   | 6   | <u>14</u> | 4   | <u>10</u> | ∞   |

   与 B 点直接相连的三个点为 C、D、E，其中在未选列表中，并且距离最短的是 E 点，下一个点为 E 点

   已选列表：S = ['A','D','B']
   未选列表：U = ['C','E','F']
   A-B 最短路径确认，更新到上面最短路径表格最短路径表格

1. 在未选列表中，剩下最小距离为 E 点。按照 A-D-B-E-其他点 方案，更新到未选列表中其他点的距离。

   1. C 点 更新为 11
   2. F 点 更新为 22

   | A   | B   | C         | D   | E   | F         |
   | --- | --- | --------- | :-- | :-- | :-------- |
   | 0   | 6   | 14        | 4   | 10  | ∞         |
   | 0   | 6   | <u>11</u> | 4   | 10  | <u>22</u> |

   与 E 相连的 D、B、C、F 中，其中在未选列表中，并且距离最短的是 C 点，下一个点选择 C 点

   已选列表：S = ['A','D','B','E']
   未选列表：U = ['C','F']
   A-E 最短路径确认，更新到上面最短路径表格

1. 在未选列表中，剩下最小距离为 E 点。按照 A-D-E-C-其他点，更新

   1. F 点 更新为 16

   | A   | B   | C   | D   | E   | F         |
   | --- | --- | --- | :-- | :-- | :-------- |
   | 0   | 6   | 14  | 4   | 10  | ∞         |
   | 0   | 6   | 11  | 4   | 10  | <u>16</u> |

   与 E 相连的只剩最后一个点 F 了，此时的距离就是最终结果了  
   已选列表：S = ['A','D','B','E','C','F']
   A-C、A-F 最短路径确认，更新到上面最短路径表格

## 代码实现

### 数据结构

![Dijkstra-2](./images/Dijkstra-2.png)

如图，可以使用二维数组表示各点之间的距离

```js
const matrix = [
  [0, 10, Infinity, 4, Infinity, Infinity],
  [10, 0, 8, 2, 6, Infinity],
  [Infinity, 8, 10, 15, 1, 5],
  [4, 2, 15, 0, 6, Infinity],
  [Infinity, 6, 1, 6, 0, 12],
  [Infinity, Infinity, 5, Infinity, 12, 0],
];
```

记录最短距离的数组 distance，初始值就等于 matrix[0]

已经确定最短距离的点不参与后续计算。在二维数组中，索引就对应着每个点，可以再用一个和 matrix 相同长度的数组 nodes，每个对应位置的布尔值表示当前位置的点是否已经被计算过。同时循环结束的条件就是 node 数组中不再包含为 false 的值。

### 代码思路

按照前述分析，不断重复的过程是：

1. 获取最短距离的数组 distance 中值最小的点（已经计算过的点，不再参与最小值计算），值记为 minValue，对应索引记为 minValueIndex
2. 比较 distance 数组中原来每个位置的值，和新的经过最短路径的算出来的路径值进行比较，如果新值更小，则更新到数组中。

   - minValueIndex 点，到达各点的距离，就是`matrix[minValueIndex]`数组中记录的值
   - 经过最短路径的值，就是`distance[minValueIndex] + matrix[minValueIndex][j]`

代码：./code/dijkstra.js

# 并查集（Disjoint-set data structure）

资料：

- [算法学习笔记(1) : 并查集](https://zhuanlan.zhihu.com/p/93647900)
- [并查集](https://oi-wiki.org/ds/dsu/)

## 连续出牌数量题目分析

如图，题目意思可以理解为要求{num, color}顶点的联通关系，相同 num 或者相同 color 的顶点可以联通。也就是两个元素只要满足其中一个联通条件，就可以放到一个集合中。然后找到元素数量最多的集合，这个数量就是答案。

![2-11-并查集](./images/2-11-并查集.png)

并查集就是用来解决元素分组的问题。

1. 先按照<相同 num 或者相同 color>的规则，以 nums 和 colors 为原始数据，构造并查集。
2. 再统计集合中元素数量，找到最大数量的。

## 代码分析

代码：exercise/level-2/11.连续出牌数量-答案.js

1. 按照规则构造并查集 ufs，执行`ufs.union(i, j);`，最后就形成了两个集合。过程解析：

   数据：
   nums [1, 4, 3, 4, 5]
   colors ["r", "y", "b", "b", "r"]

   并查集初始化，每个位置的值就是存储索引
   ufs [0, 1, 2, 3, 4]

   执行`ufs.union(i, j);`过程：

   索引 0 和 4 的元素满足花色相同 放到一个集合，要访问 4，通过 0 代理，将 4 位置改成 0
   ufs [0, 1, 2, 3, 0]

   索引 1 和 3 的元素满足数字相同 放到一个集合，要访问 3，通过 1 代理，将 3 位置改成 1
   ufs [0, 1, 2, 1, 0]

   索引 2 和 3 的元素满足数字相同 放到一个集合，要访问 3，通过 2 代理
   由于上一步访问 3，通过 1 代理，所以是拿 1 位置上的数字，将 1 位置变成了 2 位置的数字
   ufs [0, 2, 2, 1, 0]

   也就是，0 和 4 元素在一个集合中，访问 4 位置元素时，4 位置存放的它代理 4 元素的父级 0 元素的索引，通过该索引可以拿到 0 的索引。
   1、2、3 元素在一个集合中，3 的父级为 1，1 的父级为 2，2 就是指向自己，每个位置存储的是自己父级的索引。

2. 再遍历，找到在一个集合中的元素。对象 count，键为代表集合根级的索引，值记录集合中有多少个元素，最后取出最大的那个。
   count {0: 2, 2: 3}

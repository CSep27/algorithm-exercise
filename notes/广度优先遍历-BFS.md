# 广度优先遍历（breadth first search）

## 39-欢乐的周末

### 总体思路

根据 deepseek 的答案，总结思路实现：

1. 找到 2
2. 以 2 为起点，尝试往四个方向走，如果遇到 1 表示走不通，其余的都能走通。如果遇到 3，则记录下 3 的位置（记录两个起点能到达的 3 的位置）
3. 最终比较两个位置中是否有重叠的，有则结果+1

### 广度优先搜索

难点在于第二点，也就是广度优先搜索的过程

以 2 为起点，放入队列中
尝试四个方向，先判断是不是边缘位置，非边缘位置继续

- 判断是未访问过的节点
  - 如果是 1，不可到达，不处理
  - 可到达（0，2，3），放到队列中，等待当前节点处理结束后，再继续处理队列
    - 如果是 3，记录下来（需要有数据结构）
  * 将当前节点记录为已经访问过的点

重复上述步骤，循环条件为队列里是否有值
队列就是每次当前节点的四周的节点中，满足未访问过，并且可达的节点，会在处理过程中被放入队列中

这样会以起点为中心，向四周扩散搜索

如何获取一个节点四个方向的节点，把当前节点当做[0,0]，根据四个方向节点的相对坐标，计算出实际坐标值

### 设计数据结构

1. 存储两个起点 persons [[], []]
2. 队列：[`${x},${y}`, `${x},${y}`, ...]
3. 记录两个起点对应可达的饭店的位置：new Set(`${x},${y}`)
4. 记录已访问过的节点：new Set(`${x},${y}`)

### 总结

1. 理解题意
2. 根据示例，数据数量少，尝试按照最基础，最直觉的做法得到答案
3. 将基础做法细化为一个个的步骤
   - 比如本题中，从[0,0]位置的 2 开始，为什么我直接知道是往下走，其实是因为上和左是边缘，右是障碍物，而人在直接看的过程中其实已经判断过这一点了
   - 但对于机器来说并不会直接判断，而需要尝试，结果是因为不满足限定的条件，那么这就对应了解题步骤
   - 因为机器就是擅长做重复工作，而算法就是告诉机器如何做重复工作，增加限定条件，让机器如何以最高的效率完成重复工作，得到我们想要的结果。
   - 继续这个过程，到了 2 下方的 0，会继续重复上一步的过程。人会知道继续往下走，左右的条件和前面一样，而不去上面是因为是回头路，也就是已经访问过了。那么相应的对于机器来说怎么知道，就需要有个东西去记录下来所有已经访问过的点了。这样会提高查找的效率。
   - 再继续往下时，会发现右边和下边都可以访问，前面都是只有一个节点能继续，那么这里两个节点后面都需要尝试，那么又需要有个东西存储所有可以联通的节点，后面需要依次尝试。这个东西是先进去先处理的，那么就是需要用到队列。
   - 细分找到重复的规律后，还需要思考到全局。这是一个从起点开始，重复去判断四周相连的点的循环，把能联通的点都放入队列，每次从队列里拿出来一个节点做处理判断，当队列里的点都处理完了，那么就是循环结束的时候。
   - 如何获取周边点，通过坐标计算，也是统一的规律
   - 每个点要做什么，前面都分析了，把过程捋出来也就是循环体里要写的处理逻辑代码
4. 分析下来基本的解题思路就有了，按照第三步编码就差不多了。
5. 第三步过程中会涉及到如何存储数据更方便，那么首先需要了解清楚各个数据结构的特点，然后根据当前题目中这个数据的特点选择对应的数据结构进行存储。
6. 进行编码，实现基础版
7. 优化写法，查找逻辑上是否有需要优化的地方
8. 分析时间复杂度，看是否可以优化
9. 总结解题思路
   - 如果是没有接触过的类型（比如并查集），完整的再捋一遍过程，弄明白为什么是这么想，为什么是这么解
   - 如果是接触过的类型，那么要想一想有没有哪些不同点
10. 练习练习

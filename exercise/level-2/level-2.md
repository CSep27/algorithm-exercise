# 1. 最长广播响应

Dijkstra 迪杰斯拉特算法 求解最短路径。

结果是最短路径数组中，最长的那一个 乘以 2。广播发过去再响应回来。

# 5. 最小传输时延

Dijkstra 迪杰斯拉特算法分析，记录在../notes/Dijkstra 算法.md 中。

答案解法用到的也是迪杰斯拉特算法思想，数据结构和具体实现有所不同。

待完成一遍

# 11. 连续出牌数量

1. 第一种遍历解法，时间复杂度高
2. 使用并查集处理：notes/并查集.md

# 12. 简易内存池-区间

答案思路：

1. 定义一个 used 数组存放已使用的区间
2. 分配时，每次 start=0 开始，根据 size 计算 end，得到期望分配的区间地址[start,end]，循环 used 数组，判断[start,end]与 used[i]是否存在交集。若存在，更新 start 的值为`used[i][1] + 1`，也就是当前 used[i]区间结尾的下一个元素，重新计算 end，再与下一个 used[i]比较。知道找到不存在交集的部分，则是可以分配的区间。
3. 释放时，根据 addr（需释放的首位地址），去 used 中查找，找到从数组中删除。

# 13. 区间交集

1. 判断两个区间有没有交集
2. 区间合并

# 19. 学生方阵

F M M F
F M M F
F F F M

找 M 连在一起最长的线，水平、垂直、正对角线、反对角线均可

答案思路：

1. 遍历每个 M 点，求该点四个方向上 M 点的个数
2. 需要**剔除重复查找**的场景：

- M 点左边是 M 时，不需要计算水平方向
- M 点上边是 M 时，不需要计算垂直方向
- M 点左上是 M 时，不需要计算正对角线方向
- M 点右上是 M 时，不需要计算反对角线方向

# 20. 发广播

想到并查集解法了！！！

# 24. 高效的任务规划

## 题目分析

一次只能配一台机器，配置时间是线性的，不管每台机器时间长短，至少都需要所有机器配置时间相加。

配置完后可以同步运行，那么就应该先配置运行时间长的机器。让它先投入运行。

假设有三台设备，先按照配置时间 b 排序，然后按照时间长的先配置先运行（x 表示配置时间，a 表示运行时间，有几个表示需要多少时间），那么最优方案如下：

```
1 xxxaaa
2    xxaa
3      xa

1 b1 + j1
2 b1 + b2 + j2
3 b1 + b2 + b3 + j3
```

比较每台机器花费的时间，得到结果中最大的，就是最终需要的时间

## 输入处理

需要保留每一行的输入，在知道输入多少行的情况下，可以通过一个全局变量数组的长度来判断。但是本题不好判断输入多少行，需要在每次输入后，将数据保存到变量中。

获取一行输入内容就是一次异步操作，不知道什么时候结束，因此封装到 Promise 中，输入结束时执行 resolve。

再利用 async await 阻塞同步代码，达到异步操作同步化执行。

# 25. 完全二叉树非叶子部分后序遍历

## 知识点

1. 数据结构：二叉树、完全二叉树、满二叉树
2. 遍历顺序：后序遍历 左-右-根
3. DFS Deep First Search 深度优先遍历

## 分析

1. 顺序存储结构，用数组存储。根节点索引 i，左节点索引`2*i+1`，右节点索引`2*i+2`
2. 非叶子节点，说明至少有一个子节点，由于是完全二叉树，那么至少有一个左节点
3. 实现后序遍历：Learning-Notes/算法/code/二叉树/后序遍历完全二叉树.js
4. 增加判断在非叶子节点时，才放入结果数组

# 34. 书籍叠放 排序+二分法

```js
[
  [10, 20],
  [12, 5],
  [14, 17],
  [14, 13],
  [15, 15],
  [20, 22],
];
```

长大于并且宽也大于，可以叠放。

长度升序，长度相同时，宽度降序排列。

待完成，看了一遍答案，但是还有些没完全明白，还要再想想思路过程。

# 37. 没有回文串——数位搜索+回文子串涵盖判断

## 题意分析

回文串，中心对称，正序反序相同，比如 aba，abba，a, ''都可以算。

题目中，给定字符串中不含有长度大于等于 2 的回文子串，那么 aba 符合，abba 中，中间 bb 是长度为 2 的回文子串。

n 表示字符串中的字母在英文字母前 n 个，比如 n 为 2，那么字符串中只有 a 和 b 两个字母。

假设输入为 3，bba，那么字符串中只能包含 abc 三个字母，
字典序大于 bba 的，那么有如下情况
第一层：b
第二层：b c
第三层：b-c a-c

第一层：c
第二层：a-c
第三层：a-c

然后去掉其中有回文子串的，满足条件的第一个就是答案

如何判断是否有回文子串：

遍历时

将 str[i]分别与 str[i-1]、str[i+1]比较，若相同，含有偶数位回文串
将 str[i-1]与 str[i+1]比较，若相同，含有奇数位回文串

本题中，判断 str[i]不能和 str[i-1]、str[i-2]相同。

i >=1 时 str[i] !== str[i-1]
i >=2 时 str[i] !== str[i-2]

## 代码实现分析

假设初始字符 str 为'bba'， n=3，那么就是 abc 三个字母，为了方便在循环中递增，转换成对应的 ASCII 数值：[97,98,99]
遍历结果 push 进 result 数组中

深度优先遍历

1. 纵向需要遍历多深，也就是确定到什么时候结束遍历，本题就是遍历深度为 n，也就是当 result.length===n 时结束遍历。
2. 每一层进行循环时，循环的开始和结束。结束值 max 是等于最大值 99，要保证字典序大于 str，起始值 min 需要分析：

- 第一层 >= b （str 第一个字母）可以取 b 和 c 也就是 min = b
- 第二层 分情况
  - 当第一层是 b 时，那么第二层也必须 >= b（str 第二个字母），
  - 当第一层是 c 时，那么第二层可以从最小字母 a 开始 >= a
  - 所以结论是，当第一层取循环的初始值，为 min 时，第二层循环的初始值，min 需要设置为 str 第二个字母
- 第三层 分情况
  - 当第一层是 b 时，第二层是 b，那么第三层也必须 >= a（str 第三个字母），
  - 当第一层是 b 时，第二层是 c，那么第三层可以从最小字母 a 开始 >= a
  - 当第一层是 c 时，第二层可以从最小字母开始，第三层也可以从最小字母开始
  - 所以最终结论是，当前面的层数**都是**取循环的初始值，为 min 时，当前层循环的初始值，min 需要设置为 str 第 n 个字母。否则，从最小字母 a 开始循环。
  - 对于第一层，肯定是从 str 第一个字母开始
  - 因为 min 的取值涉及到每一层，所以需要定义一个变量 limit，用于确定 min 的取值。当为 true 时，min 从 str[i]开始。
  - 进入第一层，limit 初始为 true，进入第二层时，需要根据第一层的取值是否为 min 来判断，
    - 那么、在进入下一层时，当前层需要根据上一层是不是取 min，以及当前层是不是取 min，决定传入到下一层的

前面分析就可以找到规律了，每一层 for 循环的初始值 min 需要变化，max 固定。
按照这种通用规律，是把原始字符串 str 也囊括在内，判断一下结果如果等于 str，就弃掉，继续找下一个。
还有就是要去掉有回文子串的，按照前面分析回文子串的规律，符合规律的也弃掉，继续找下一个。

# 47. 导师请吃火锅

贪心算法

1. 算出菜合适时候的秒数
2. 第一个合适的菜必吃，到第 k 个合适的菜时，看距离上一次捞菜的时间间隔，如果大于 m，那么就捞

# 48. 最小传输时延 2

1. 一维坐标计算
2. 节点的 8 个方向

# 50. 二叉树层序遍历-广度优先搜索

前序遍历：根左右
中序遍历：左根右
后序遍历：左右根

以根的位置来定是哪种顺序，而左永远在右前面。

后序：CBEFDA
中序：CBAEDF

根据后序遍历，最后一个遍历的元素是树根，可以快速找到树根为 A。
中序遍历中，A 的左边就是左子树，右边就是右子树。
中序中，截取左右子树，根据**长度**去后序里面截取出左右子树，子树最后一个就是子树的根。
循环该操作，直到找到叶子节点，结束。

直接按照层序遍历的顺序构造树。

自己按照答案思路完成代码，待完成：优化代码。

广度优先遍历：函数执行完后从调用栈中返回结果，用队列保存结果，先进先出，从队列中取结果循环执行，直至队列为空

# 55. 跳格子游戏

待完成

条件：

- 没有前置依赖条件的格子默认是开启的
- 从一个格子可以跳到任意一个开启的格子

0 1
1 0

这种情况下，相互依赖，初始就没有开启的格子

4 3
0 4
2 1
3 2

每行分析最后得到：1->2->3->4->0 ，0 是初始就开启的格子

按照自己的思路已完成。待完成：看下答案的思路。

# 59. 计算疫情扩散时间-广度优先算法

待完成

学了 50 广度优先搜索，就明白思路了！

# 60. 观看文艺汇演问题——区间问题/最多不相交区间个数

根据演出持续时间，计算时间区间，按照结束时间升序排列。然后计算当前 start 和上一个 end 的差值，大于等于 15，则数量加一。

# 61. 快速人名查找——回溯算法

第一个子串匹配上第一个字符的，到下一个子串中看是否匹配第二个字符，不匹配则回到第一个字符串继续找，如果匹配从从当前子串开始重复上述逻辑。

避免缩写字符串 abbr 的指针回溯，会使逻辑复杂。

不清楚查找次数，回溯递归。

自己按照答案思路写了，构造了一些例子能通过。

待完成：看下答案的写法

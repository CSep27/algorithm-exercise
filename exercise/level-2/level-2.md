# 5. 最小传输时延

Dijkstra 迪杰斯拉特算法分析，记录在../notes/Dijkstra 算法.md 中。

答案解法用到的也是迪杰斯拉特算法思想，数据结构和具体实现有所不同。

待完成一遍

# 19. 学生方阵

F M M F
F M M F
F F F M

找 M 连在一起最长的线，水平、垂直、正对角线、反对角线均可

答案思路：

1. 遍历每个 M 点，求该点四个方向上 M 点的个数
2. 需要**剔除重复查找**的场景：

- M 点左边是 M 时，不需要计算水平方向
- M 点上边是 M 时，不需要计算垂直方向
- M 点左上是 M 时，不需要计算正对角线方向
- M 点右上是 M 时，不需要计算反对角线方向

# 24. 高效的任务规划

## 题目分析

一次只能配一台机器，配置时间是线性的，不管每台机器时间长短，至少都需要所有机器配置时间相加。

配置完后可以同步运行，那么就应该先配置运行时间长的机器。让它先投入运行。

假设有三台设备，先按照配置时间 b 排序，然后按照时间长的先配置先运行（x 表示配置时间，a 表示运行时间，有几个表示需要多少时间），那么最优方案如下：

```
1 xxxaaa
2    xxaa
3      xa

1 b1 + j1
2 b1 + b2 + j2
3 b1 + b2 + b3 + j3
```

比较每台机器花费的时间，得到结果中最大的，就是最终需要的时间

## 输入处理

需要保留每一行的输入，在知道输入多少行的情况下，可以通过一个全局变量数组的长度来判断。但是本题不好判断输入多少行，需要在每次输入后，将数据保存到变量中。

获取一行输入内容就是一次异步操作，不知道什么时候结束，因此封装到 Promise 中，输入结束时执行 resolve。

再利用 async await 阻塞同步代码，达到异步操作同步化执行。

# 25. 完全二叉树非叶子部分后序遍历

## 知识点

1. 数据结构：二叉树、完全二叉树、满二叉树
2. 遍历顺序：后序遍历 左-右-根

## 分析

1. 顺序存储结构，用数组存储。根节点索引 i，左节点索引`2*i+1`，右节点索引`2*i+2`
2. 非叶子节点，说明至少有一个子节点，由于是完全二叉树，那么至少有一个左节点
3. 实现后序遍历：Learning-Notes/算法/code/二叉树/后序遍历完全二叉树.js
4. 增加判断在非叶子节点时，才放入结果数组

# 47. 导师请吃火锅

贪心算法

1. 算出菜合适时候的秒数
2. 第一个合适的菜必吃，到第 k 个合适的菜时，看距离上一次捞菜的时间间隔，如果大于 m，那么就捞

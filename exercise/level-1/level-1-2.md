# 61. 滑动窗口最大和

n，整数个数，m 窗口大小

左指针范围 0 <= left <= n-m

# 63.

符号整数 指正整数
用正则匹配替换求解 reduce

# 64. 猴子爬山

| 台阶数 n | 跳跃方式 | 如何跳跃                                                  |
| -------- | -------- | --------------------------------------------------------- |
| 1        | 1        | 1                                                         |
| 2        | 1        | 11                                                        |
| 3        | 2        | 111<br />3                                                |
| 4        | 3        | 1111 <br />13<br />31                                     |
| 5        | 4        | 11111 <br />113<br />131<br />311                         |
| 6        | 6        | 111111 <br />1113<br />1131<br />1311 <br />3111 <br />33 |

- 跳 4 级台阶可以转化为跳 1 级和 3 级台阶
- 跳 n 级台阶可以转化为跳 n-1 级和 n-3 级台阶

动态规划：

- 最优子结构：f(n-1) f(n-3)
- 状态转移方程：f(n) = f(n-1) + f(n-3) (n>3)
- 临界条件 f(1) = 1 f(2) = 1 f(3) = 2

# 65.We are a team

并查集解决。题目的意思是给定两个数在一个集合中，比如一和二在一个集合中，二和三在一个集合中，判断一和三在不在。

# 66.

sort 多条件排序

# 67.数组组成的最小数字

先按大小排序，再使用 sort 默认排序

# 68.

sort 排序
str.at(-1)取字符串最后一位数

# 69. 运维日志排序

正则匹配获取时分秒毫秒，统一转换成毫秒，比较大小后排序。

使用 sort 比较，相同的会保持输入顺序

# 70.

# 71. 比赛

> 难点：如果得分相同，则得分高分值最多的选手排名靠前

自己思路：做出来了，但是对于上述逻辑的实现不够完善。

答案思路：将选手分数降序排序后，`join("")`为字符串数值，高分多的选手该字符串数值越大！

知识点：使用 sort 排序时，可以在函数里面写判断逻辑，针对多种判断的情况。

# 72.

# 73. 磁盘容量排序

稳定排序：当容量相等时，保留原来的相对位置

**Array.prototype.sort 为稳定排序**。

# 75. 字符串排序

1. 先排序后去重，基于栈结构去重，排序后，不区分大小写的两个字符串是挨着的

# 76. 翻牌求最大分

题目表述有问题，看答案明白了。arr 中存每张牌的数字，dp 存每次的得分

1. 当前的得分 = 上一次得分 + 当前牌数字 `current = dp[i - 1] + arr[i]`
2. 1-3 次，当前的得分如果小于 0 的话，取 0，`current = Math.max(0, current)`
3. 大于 3 次时，判断 计算的当前得分 与 往前数三次（i-3）的得分 大小，取更大的作为最终当前得分。`current = Math.max(dp[i-3], current)`

# 79. 堆栈中的剩余数字

dp => dynamic programming [动态规划](https://zhuanlan.zhihu.com/p/365698607)

答案解题思路：

1. 求出数组 arr 对应的数组 dp，比如

| arr | 1   | 2   | 5   | 7   | 9   | 1   | 2   | 2   |
| --- | --- | --- | :-- | :-- | :-- | :-- | :-- | :-- |
| dp  | 1   | 3   | 8   | 15  | 24  | 25  | 27  | 29  |

dp 数组第 i 位的值 dp[i] = arr[i] + dp[i-1]，也就是 0~i-1 的元素之和

2. 用指针 i 扫描，比较 arr[i] 和 dp[i-1]的关系

- arr[i] === dp[i-1]，就是满足题目条件，0~i-1 的元素之和等于 arr[i]。把元素之和合并入 arr[i]中，即 arr[i] = 2 \* arr[i]。0~i-1 范围内的元素全部置为 0。
- arr[i] > dp[i-1]，说明前面 k~i-1 (0 <= k <=i-1) 所有元素加起来无法满足题目条件，无法合并。
- arr[i] < dp[i-1]
  - 如果能找到 k (0 < k <= i-1)，使得 k~i-1 所有元素加起来满足题目条件。k~i-1 的元素之和等于 arr[i]。把元素之和合并入 arr[i]中，即 arr[i] = 2 \* arr[i]。k~i-1 范围内的元素全部置为 0。
  - 如果找不到 k，无法合并
- 最后去掉数组中为 0 的元素，反序输出

# 80. 5 键键盘

# 81. 报数游戏

约瑟夫环问题，利用循环链表

1. 指针指向 list.head 为当前元素，初始化为 1，依次增加，到 M 位置时，删除该位置元素
2. 删除后，指针重置为 1
3. 循环上述步骤，直到链表长度小于 M

构造循环链表

1. CircularLinkedList 实例：size 链表大小 head 指针 tail 指针
2. 循环链表：head.prev = tail tail.next = prev
3. 提供 init 方法将数组初始化为链表，init 方法中通过 append 方法将每个元素变为链表节点 Node
4. 链表节点 Node 实例：value 内容 prev 指向上一个元素 next 指针指向下一个元素

# 82. 高矮个子排队

用例有问题，并没有实现题目中说的，最小移动距离，而是只要遇到不符合要求的就换位置。答案是按照这种写法的。

# 83. 工号不够用了怎么办？

Math 的几个方法：`Math.max(1, Math.ceil(Math.log10(x / Math.pow(16 / y))));`

# 84.

# 85. 喊 7 的次数重排

理解题目的意思，首先知道有多少个人参与了游戏，然后是一共喊了多少次过，参与游戏的人数就是数组的长度。喊了多少次过就是数组的值之和。由于数字最大不超过 200，可以根据喊过的次数得到所有的与 7 相关的数字，然后用这个数字对 N 取余就是对应的索引值。

# 88. 最小交换次数

## 题目

有一个数组 arr。给出数字 k。请输出数组中所有小于 k 的整数组合到一起的最少交换次数。组合到一起是指满足条件的数字相邻，不要求相邻后在数组中的位置。

数据范围：-100 <= k <= 100

例如：arr = [1,3,1,4,0] ; k = 2。最少交换次数：1。0 和 3 交换。

## 思路

滑动窗口求解。

1. 首先统计出数组中小于 k 的整数的数量 count。就是滑动窗口的大小。注意滑动起点的起始范围：[0, arr.length-count]
2. 统计滑动窗口中大于 k 的整数的数量。就是需要交换的次数。
3. 滑动窗口右移，比较得到最小交换次数。

普通做法双重循环算法复杂度为 O(n^2)

## 优化点

当滑动窗口移动一格时，中间的元素已经计算过了。此时只需要将减少的元素和增加的元素与 k 进行比较。

- 如果都小于或者都大于 k，那么交换次数相同。
- 如果减少的元素小于等于 k，增加的元素大于等于 k，那么交换次数增加。
- 如果减少的元素大于等于 k，增加的元素小于等于 k，那么交换次数减少。

# 89. 字符串分割

1. 先将字符串通过`String.prototype.charCodeAt()`方法变成 ascii 码值数组 arr
2. 计算前缀和
3. 递归，具体见代码

# 91. 全排列

N 个元素排列不考虑重复与否，那么有 N 的阶乘种排列方式，如果其中一个元素重复了两次，那么重复的排列，就有二的阶乘，所以完全不重复的排列次数为 N 的阶乘 ÷2 的阶乘，如果还有一个元素重复了三次那么最终结果就是 N 的阶乘 ÷2 的阶乘再 ÷3 的阶乘。

# 92. 解密犯罪时间

答案的解法：将四个数字进行全排列得到一个数组，通过正则筛选去掉不符合时间格式的值，剩下的值进行排序，找到其中刚好大于指定值的值，如果指定的值在数组的末尾，那么就取数组的第一个

# 94. 数组连续和

利用一维前缀和

# 95. 数大雁

1. 叫声需要连续并且完整，记录所有叫声区间['q 索引','k 索引']，多少区间表示有多少声叫声
2. 题目要求求得最少有几只大雁，区间有交集的部分，表示有大雁同时发声，区间不相交，可以是同一只大雁重复发出声音。所以交集数量加一也就对应了最少大雁的数量
3. 每一个区间都需要与后面的算交集，取最大交集数

- 'quackquack'，[0,4] [5,9]两个区间，交集数为 0，最少大雁为 1，即 1 个大雁叫了两声。
- 'quackquacqkuack'，[0,4] [5,10] [9,14] 两个区间，交集数为 1，最少大雁为 2，[0,4]，第一个区间与后面的交集为 0；第二个区间与后面的交集数为 1 后面两个区间有交集，则至少是 1+1= 2 只大雁同时叫了。

# 96. 篮球比赛

1. 10 选 5 组成一队，剩下为另一队，计算战斗力差值，获得最小的

## 数学知识：排列组合

排列，是看顺序的，12345 和 12354 是不同的排列。
组合，是不看顺序的，12345 和 12354 都是由同样的 5 个数组合而成，是一种组合。

10 个数选择 5 个排列，记为`A(10, 5)`，第一个位置是 10 种选择，第二个是 9 种，依此类推，可以有 `10*9*8*7*6` 种选择。所以`A(10, 5) = 10*9*8*7*6`。

10 个数选择 5 个组合，记为`C(10, 5)`，就是在`A(10, 5)`排列中去掉数字相同的排列。数字相同的排列，可以看做是在 5 个数中，选择 5 个数进行排列，就是`A(5, 5)`。那么除掉相同的，所以`C(10, 5)= A(10, 5)/A(5, 5) = (10*9*8*7*6)/(5*4*3*2*1) = 252`，和算法中分队有多少种情况一致。

# 97. 数字翻转打印

# 98. 最大矩阵和

答案思路：对于 3×3 行的矩阵，首先将每一行作为一个子矩阵，然后是每两行作为一个子矩阵，最后是三行作为子矩阵。

对于每一行来说，问题就转化成求一维数组的矩阵和。

两行作为一个子矩阵也可以转化成一维矩阵。三行同理。

自己按照思路实现了，但是写法可以优化，列数据之和也可以用求前缀和的方式计算？

答案还没看，应该是更简洁。待完成

# 99. 停车场车辆统计

replaceAll 方法

# 100. 太阳能板最大面积

1. 第一种：双重循环暴力破解
2. 第二种：双指针，找固定矮柱的最大面积，O(n)

# 101. 绘图机器

看懂题目意思即可

# 102. 最大时间

1. 6 个数字深度优先搜索进行全排列，过滤掉不符合时间格式的
2. 值进行比较，取值最大的，输出为符合条件的格式

# 103. 第 k 个的排列

答案思路：

n=3
arr=[1,2,3]
123 132 213 231 312 321 共 3!=6 个数
k=3

1. 6（n!）个数，一共 3（也就是 n）组，每组 2（(n-1)!）个数，对于第 3（k）个数，可以算出在第 2 组（Math.ceil(k/(n-1)!)）。开头数字为 2，也就是对应 arr 中的 2。
2. 数字 2 在 arr 数组下标为 1，通用计算获取数为 index = Math.floor((k-1)/(n-1)!)。（k-1 是先把 k 转换成和下标一致），arr[index]就是第一个数字
3. 问题转化为在 213 231 两个数中，找出 newK=1 的对应的数字
4. 需要在 213 231 中找，k 不再是 3，而是 1。newK 的转化公式：newK = k % (n-1)!，当 newK 算出来为 0 时，整除了，表示是最后一个数，也就是(n-1)!，所以最终 newK = k % (n-1)! === 0 ? (n-1)! : k % (n-1)!（此时 n 还是 3）
5. arr 中剩下[1,3]两个数，arr 更新，n 更新为 2 组，每组 1 个数
6. 可以看出此时就是需要的数字排列，所以结束条件为 k===1。此时数组排列顺序，就是
7. 如果 k !== 1，再根据更新后的 k 和 n 重复第二步，得到新的 index，也就获取到了下一个数字。直到触发 k===1 的结束条件

# 104. 计算礼品发放的最小分组数目

1. 降序排列，等于价格上限的，单独作为一组
2. 剩下的左右指针指向首尾，相加

- 和若大于上限，左边单独为一组，左指针++，
- 若小于等于上限，则为一组，左++，右--

# 105. 找车位

自己思路：

1. 左右指针，如果都指向 1，中间值间距为 `Math.floor((right - left) / 2)`。再判断更新最大长度
2. 边缘情况，左 0 右 1，或者左 1 右 0，间距为 right - left。同样判断更新最大长度

答案思路：

1. 用 1 去 split 字符串，得到全部为 0 的子串
2. 判断边缘情况就是子串长度，非边缘情况就是 `Math.ceil(subStr.length/2)`

整体都差不多

# 106. 判断字符串的子序列

# 107.求最多可以排除多少支团队

1. **将数列降序**，[9,6,5,3,1]，大于等于 8 的直接组队
2. 小于 8 的数，双指针，左指针指向 6，右指针从末尾开始找，找到和 7 相加大于等于 8 的第一个数 3。左右指针都++，直到左指针大于等于右指针。1+6 小于 8，所以不会再有能组队的了。

# 108. 流水线

1. 将时长 t 按照升序排序
1. 如果 n <= m，返回时间 t 中最长的即可
1. 如果 n>m，取最长时长所在的流水线上，所有时长相加。

# 109. 事件推送

注意理解对题目意思，画图！！！大数据量题目尤其需要考虑算法效率

1. Ai <= Bj
2. Ai 和 Bj 之间距离小于等于 R

通过二分查找，如果找到 Ai===Bj ，就是满足要求并且距离最近，否则找到的位置也就是 Ai 有序插入 B 中的位置，此时判断后面一位数与 Ai 的距离小于等于 R 就是答案，否则就是没有。

二分法获取中间值：数字右移 1 位`num >> 1`，效果相当于`Math.floor(num / 2)`

# 110. 找朋友

题目的意思是，第 i 个人，往后看找（序号比 i 大），找到的第一个比 arr[i]数值大的索引，放到结果数组的 i 位置。

第一种解法：双重循环，时间复杂度 O(n^2)
第二种解法：利用栈结构，将 [元素值，索引位置] 压入栈中，比较栈顶元素和当前元素的大小，若当前元素大，则栈顶元素出栈，结果 height 数组中，栈顶元素的索引位置填入当前元素的索引作为值。

算法优化思想，如果有重复的计算，通过借助空间将计算结果存储下来，减少计算次数。

# 111. 统计射击比赛成绩

简单排序问题

# 112. 分苹果

没看懂题目

1. **二进制不进位就是按位异或**（相同为 0，不同为 1）：a ^ b
2. 十进制进位就是正常加法
3. 满足 A 的分法的话，所有数异或结果为 0（因为最终两个相同的数异或结果为 0，计算后的两个数相同也就意味着按照 A 的分法平分了）
4. B 获得重量最大，只需要把所有苹果中重量最小的给 A，剩下的给 B

# 113. 最大股票收益

前提：手上只能保留一只股票

股票买入要花钱，卖出赚钱，所以最赚钱是低买高卖。

贪心思维，买涨不买跌。

# 114. 单词重量

保留两位小数并四舍五入：Number.prototype.toFix(位数)

# 115. 金字塔，BOSS 的收入

自己的解法，增加 parent 引用父级代理商
答案解法，利用二维数组，更简单

# 116.

# 117.

# 118. 免单统计

答案做法简洁

# 119.

# 120. 德州扑克

1. 大小和花色分开存储

2. 四条（四张牌相同，一张牌不同）的判断，用 new Set()去重，去重后只有两张牌。取其中一张判断在 nums 中有几个，若为 1 个或 4 个，可以判定为 4 条。

# 121. 两数之和绝对值

正序排列 nums，和的**绝对值**为最小值

1. 第一个数 >=0，那么都 >=0，就是 nums[0]和 nums[1]
2. 最后一个数 <=0，那么都 <= 0，就是最后两个数
3. 有正值和负值情况，一个找正值，一个找负值。[-11, -5, 3, 10, 20]

- 二分法找 0 的位置，得到正负值的分界位置。
- 如果有 0
- 正值和负值那个数量少，负值
- -11 取相反数 11，在正值队列中通过二分法，找到 11 所在的位置，前为 10，后为 20，算差值，取较小的为 1
- -5 取相反数 5，在正值队列中通过二分法，找到 5 所在的位置，前为 3，后为 10，算差值，取较小的为 2
- 那么最终最小的就是-11 和 10，和的绝对值为 1

# 122. 整数编码

- 原码 数字本身
- 反码 原码除符号位按位取反
- 补码 反码加一
- 正数的原码、反码、补码都相同，都等于原码；负数的反码等于除符号位按位取反，负数的补码等于反码末位加 1。

本题都是非负整数，补码与原码相同。

小端序，低位放在低地址。

举例：1000
二进制 0011 1110 1000，至少需要两个字节。
第一个字节，第一位放 1，表示还有字节，剩下放七位 110 1000，组合起来就是 1110 1000 ，转换成 16 进制 E8。
第二个字节，第一位放 0，表示接下来没有字节了，剩下放七位 000 0111，组合起来就是 0000 0111 ，转换成 16 进制 07。
最终结果为 E807

思路：

num.toString(2) 转换成二进制，长度除以 7，再加一，就是需要占多少个字节。

str.slice()方法从尾部截取数字，参数可以是负数，包括 start 不包括 end

# 103. 第 k 个的排列

答案思路：

n=3
arr=[1,2,3]
123 132 213 231 312 321 共 3!=6 个数
k=3

1. 6（n!）个数，一共 3（也就是 n）组，每组 2（(n-1)!）个数，对于第 3（k）个数，可以算出在第 2 组（Math.ceil(k/(n-1)!)）。开头数字为 2，也就是对应 arr 中的 2。
2. 数字 2 在 arr 数组下标为 1，通用计算获取数为 index = Math.floor((k-1)/(n-1)!)。（k-1 是先把 k 转换成和下标一致），arr[index]就是第一个数字
3. 问题转化为在 213 231 两个数中，找出 newK=1 的对应的数字
4. 需要在 213 231 中找，k 不再是 3，而是 1。newK 的转化公式：newK = k % (n-1)!，当 newK 算出来为 0 时，整除了，表示是最后一个数，也就是(n-1)!，所以最终 newK = k % (n-1)! === 0 ? (n-1)! : k % (n-1)!（此时 n 还是 3）
5. arr 中剩下[1,3]两个数，arr 更新，n 更新为 2 组，每组 1 个数
6. 可以看出此时就是需要的数字排列，所以结束条件为 k===1。此时数组排列顺序，就是
7. 如果 k !== 1，再根据更新后的 k 和 n 重复第二步，得到新的 index，也就获取到了下一个数字。直到触发 k===1 的结束条件

# 105. 找车位

自己思路：

1. 左右指针，如果都指向 1，中间值间距为 `Math.floor((right - left) / 2)`。再判断更新最大长度
2. 边缘情况，左 0 右 1，或者左 1 右 0，间距为 right - left。同样判断更新最大长度

答案思路：

1. 用 1 去 split 字符串，得到全部为 0 的子串
2. 判断边缘情况就是子串长度，非边缘情况就是 `Math.ceil(subStr.length/2)`

整体都差不多

# 107.求最多可以排除多少支团队

1. **将数列降序**，[9,6,5,3,1]，大于等于 8 的直接组队
2. 小于 8 的数，双指针，左指针指向 6，右指针从末尾开始找，找到和 7 相加大于等于 8 的第一个数 3。左右指针都++，直到左指针大于等于右指针。1+6 小于 8，所以不会再有能组队的了。

# 108. 流水线

1. 将时长 t 按照升序排序
1. 如果 n <= m，返回时间 t 中最长的即可
1. 如果 n>m，取最长时长所在的流水线上，所有时长相加。

# 110. 找朋友

题目的意思是，第 i 个人，往后看找（序号比 i 大），找到的第一个比 arr[i]数值大的索引，放到结果数组的 i 位置。

第一种解法：双重循环，时间复杂度 O(n^2)
第二种解法：利用栈结构，将[元素值，索引位置]压入栈中，比较栈顶元素和当前元素的大小，若当前元素大，则栈顶元素出栈，结果 height 数组中，栈顶元素的索引位置填入当前元素的索引作为值。

算法优化思想，如果有重复的计算，通过借助空间将计算结果存储下来，减少计算次数。

# 111. 统计射击比赛成绩

简单排序问题

# 112. 分苹果

没看懂题目

1. **二进制不进位就是按位异或**（相同为 0，不同为 1）：a ^ b
2. 十进制进位就是正常加法
3. 满足 A 的分法的话，所有数异或结果为 0（因为最终两个相同的数异或结果为 0，计算后的两个数相同也就意味着按照 A 的分发平分了）
4. B 获得重量最大，只需要把所有苹果中重量最小的给 A，剩下的给 B

# 113. 最大股票收益

前提：手上只能保留一只股票

股票买入要花钱，卖出赚钱，所以最赚钱是低买高卖。

贪心思维，买涨不买跌。

# 114. 单词重量

保留两位小数并四舍五入：Number.prototype.toFix(位数)

# 115. 金字塔，BOSS 的收入

自己的解法，增加 parent 引用父级代理商
答案解法，利用二维数组，更简单

# 122. 整数编码

- 原码 数字本身
- 反码 原码除符号位按位取反
- 补码 反码加一
- 正数的原码、反码、补码都相同，都等于原码；负数的反码等于除符号位按位取反，负数的补码等于反码末位加 1。

本题都是非负整数，补码与原码相同。

小端序，低位放在低地址。

举例：1000
二进制 0011 1110 1000，至少需要两个字节。
第一个字节，第一位放 1，表示还有字节，剩下放七位 110 1000，组合起来就是 1110 1000 ，转换成 16 进制 E8。
第二个字节，第一位放 0，表示接下来没有字节了，剩下放七位 000 0111，组合起来就是 0000 0111 ，转换成 16 进制 07。
最终结果为 E807

思路：

num.toString(2) 转换成二进制，长度除以 7，再加一，就是需要占多少个字节。

str.slice()方法从尾部截取数字，参数可以是负数，包括 start 不包括 end

# 120. 德州扑克

1. 大小和花色分开存储

2. 四条（四张牌相同，一张牌不同）的判断，用 new Set()去重，去重后只有两张牌。取其中一张判断在 nums 中有几个，若为 1 个或 4 个，可以判定位 4 条。

# 2. IPv4 地址转换成整数

## 分析题目

IPv4 地址 0000 0000 0000 0000 0000 0000 0000 0000
写成十进制，是把每八位二进制数转换为了十进制 192.123.111.111

现在就是把 192.123.111.111
先转换为二进制，也就是本来的数，去掉分隔符连接起来，就是本来的数字大小。
如果转换后的二进制数不够 8 位，需要在左侧补 0
拼接后的二进制转换为 10 进制数

写法借用了 16 进制

以 "1#0#0#0" 为例：

转换成二进制数：'00000001000000000000000000000000'

二进制转换成十进制：
parseInt('00000001000000000000000000000000', 2) => 16777216

因为`1.toString(2)`结果为 1，只有 1 位，那么就需要在左边补上 7 个 0。

这样判断就很麻烦，每个位置上都需要有 8 位，那么补齐的情况就有很多种

所以好的做法就是先把每个位置转换成对应的 16 进制数，

八位二进制数，最大值是 255，用 2 位 16 进制数就能表示了

parseInt('11111111', 2) => 255
parseInt('ff', 16) => 255

所以转换为 16 进制，左侧只需要判断一下补 1 个 0 即可。

---

总结：

IPv4 地址，是 32 位二进制数。每 8 位用一个十进制表示，就是 128.255.255.255 这种格式。

这题是要把 128.255.255.255 的分隔符去掉，转换成原始 32 位二进制数，再用十进制去表示。

如果直接做，1 转换为二进制还是 1，但是需要在左边补 0，就存在需要给八位数进行补位的情况，很麻烦。借用十六进制解决。只需要补 1 位即可。

所以好的解法是先转换成 16 进制，补 0 之后再转换成 10 进制。

考察：对于 IPv4 的了解，以及进制知识。

## Number 用法

见 test

`null == 0` true
`'' == 0` true
`undefined == 0` false

# 3. VLAN 资源池

1. 提取逻辑处理中公共的部分
2. 考虑复用数组

# 4. 求字符串中所有整数的最小和

1. 计算数字时注意考虑超大数字的情况，使用 BigInt

# 5. 求满足条件的最长子串的长度

## 要求

1. 只包含一个字母，其余是数字
2. 字母可以在子串中任意位置
3. 全部是字母或者全部是数字，返回-1；那也就是说长度不可能为 1，至少为 2

## 实现

1. 滑动窗口求解思想

左右两个指针，刚开始都在 0 位置，记录字母数量
右指针右移，判断此时是不是超过了一个字母

- 如果不超过，则右指针继续右移
- 如果超过，那么此时窗口就有 2 个字母
  - 分析：
  - 则左指针++吗？但是只++某些情况下会有问题
  - 如果左指针指向的是数字，++不会减少字母数量
- 所以**实际**需要判断

  - 如果左指针指向的是字母，则++，即可
  - 如果左指针指向的是数字，
    - 分析，是直接 left=right 位置吗，也不是
    - **实际**left 应该移动到第一个字母后面的一个位置 target，
    - 如果 target 是数字，则就是移动到 target 位置，这样就避免数字损失
    - 如果 target 是字母，那其实就是右指针的位置，

- 所以在右指针移动过程中，需要记录字母在的位置的索引，这样才能取得 target 的位置

- 还需要一个变量记录左右指针之差就是长度，最后拿最长的那个

## 待完成

答案的写法更简洁，再看看

# 6.

# 7. 一种字符串压缩表示的解压

判断不合法

1. 原始压缩后字符串 str：2dff
   解压后 s1，按照正确的压缩算法压缩得到字符串 s2，
   如果 str!=s2，说明 str 不合法

2. 压缩后的字符串只有数字和小写字母，出现其他字符不合法

# 8.矩阵最大值

数量级不大，所以可以考虑暴力解法，双重 for 循环

# 9. 单词接龙

考察数组方法：splice sort at shift

剩下的单词存放在对象 prefix 中：

- 键：首字母
- 值：同一个首字母的单词存放的数组中

# 10. 找出符合要求的字符串子串

1. 数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。可以给字符串和数组去重`const arr = [...new Set(str)]`

2. sort() 方法**就地**对数组的元素进行排序，并返回对相同数组的引用。默认排序是**将元素转换为字符串**，然后**按照它们的 UTF-16 码元值升序排序**。也就是直接调用 sort 即可满足 ASCII 的值从小到大排序

# 11. 字符串加密

字符串方法：

- String 的 charCodeAt() 方法返回一个整数，表示给定索引处的 UTF-16 码元，其值介于 0 和 65535 之间。`'a'.charCodeAt()` => 97
- String.fromCharCode() 静态方法返回由指定的 UTF-16 码元序列创建的字符串。`String.fromCharCode(97)` => 'a'

把字符串转换成码元数字

# 13. 按单词下标区间翻转文章内容

1. 边界值处理，通过比较大小，得到合法的 startIndex 和 endIndex
2. 翻转操作就是前后对应的值互换，使用双指针实现

# 14. TLV 解析

1. 小端序
2. 16 进制码流字符串: 32 01 00 AE
   - 32 表示 tag 占一个字节，16 进制就是两位数
   - 01 00 表示 length，小端序，改成阅读方便的就是 00 01，也就是长度为 1 个字节
   - AE 那么紧跟着的这个字节就是 value
3. 思路：字符串转换成数组，按顺序处理
4. 答案思路：不断删除掉处理过的数组成员

# 16. 连续字母长度

1. 思路：下一个字母和上一个相同时，长度增加，不同时存储长度，注意最后一个字母的情况

# 17. 拼接 URL

1. 不管有没有/，都加上，那么至少会有两个/，再通过正则匹配替换
   `'/abc//a'.replace(/\/\/+/,'/') ` => `'/abc/a'`
2. ?? 空值合并运算符

# 18. 非严格递增连续数字序列

1. 双指针
   首先指向 0，判断是字母，都++
   判断是数字，右指针++
   判断右指针数字是否等于左指针数字，或者等于左指针数字+1

# 19. 相对开音节

1. 普通做法先反转，再用正则匹配。
2. 由于最后只需要获得符和条件的子串有多少个，所以可以把正则反转。这样减少一次的反转操作。
3. 需要匹配的子串长度为四。所以相当于有一个长度为四的滑动窗口。不断往后滑动。用正则去匹配。符合条件则结果长度加 1，联想到 tcp 协议中的滑动窗口。

# 21. 字符串序列判定

1. 双指针，两个指针 i 和 j，分别指向两个字符串 s 和 l 的开始位置。当两个指针指向的字符相同时，那么指针都++；如果指向的字符不同时，则 j++。s 字符串最后一个字符在 l 中的位置就是 j-1。
2. 学习利用双指针解决问题。

# 22. 最长的指定瑕疵度的元音子串

找到所有元音字符的位置索引放入新数组 arr 中
双指针遍历 arr，当 arr[i]和 arr[i+1]相差为 1，表示是两个元音挨在一起，也就是与索引相差值 1 相等。此时瑕疵度为 0。
瑕疵度计算方式：`(arr[r] - arr[l]) - (r - l)`
再判断瑕疵度与目标瑕疵度的大小，移动指针。

```
arr   [0, 4, 5, 6, 8, 10, 11, 12]
index [0, 1, 2, 3, 4, 5,  6,  7 ]
```

# 23. 考勤信息

用数组，滑动窗口

# 24. 计算最大乘积

# 25. 数列描述

# 26. 寻找相同子串

String.prototype.indexOf()

待完成：了解子串查找算法：BM 暴力算法、BMP 算法、Horspool 算法

# 27. 字符串变换最小字符串

将字符串 str 按照字典序排序得到 minStr，如果与 str 相同，则就是最小字符串。否则比较两者，找到第一个不同的字母 strArr[i]，替换为 minStrArr[i]，再再 str 中从后往前找第一个 minStrArr[i]字母的位置，就是被换下来的 strArr[i]需要换过去的位置。

String.prototype.lastIndexOf()

# 28. 找出经过特定点的路径长度

题目信息太少。答案补充后用 dfs 求解。

# 29. 全量和已占用字符集

字符串操作

# 30. 秘钥格式化

简单字符串操作

# 31. 数字字符串组合倒序

正则替换掉不符合要求的字符为空格，变成数组，reverse

`/(?<=\w)\-(?=\w)/`，匹配满足前后都是\w 的-，用 match 时，满足条件的-会捕获，前后的\w 不会捕获

非捕获元字符 ?:、?= 或 ?! 来重写捕获，忽略对相关匹配的保存。

?: 不捕获
?<= ?= 前面必须匹配，后面必须匹配
?<! ?! 前面必须不匹配，后面必须不匹配

# 32. 查找接口成功率最优时间段

解法思想与答案类似，答案的解法逻辑性更好。

## 思路

通过构建 dp 数组，计算出 arr 中前 i 个数字之和放入 dp[i]中（这样就被称为**前缀和**），之后利用`let sum = i === 0 ? dp[j] : dp[j] - dp[i - 1];`这句代码，即可得到其他范围的和。

| index | 0   | 1   | 2   | 3   | 4   |
| ----- | :-- | :-- | :-- | :-- | --- |
| arr   | 0   | 1   | 2   | 3   | 4   |
| dp    | 0   | 1   | 3   | 6   | 10  |

比如需要求 index 为 3-4 范围的和，i=3，j=4，就是 10-3=7，即`dp[j] - dp[i - 1]`。
第一个 3，是 dp 数组中的 3： 3+3=6；6+4=10 => 3+3+4=10 => 3+4 => 10-3

# 33. 在字符串中找出连续最长的数字串

有不清晰的地方，+-和.是可以不出现吗？

# 34. 找终点

# 36. 用户调度问题

[归一化](https://zhuanlan.zhihu.com/p/424518359)

# 37. 查找众数及中位数

# 38. 最大 N 个数与最小 N 个数的和

# 39. 最长连续子序列

# 40. 数组去重和排序

# 41. 数组拼接

Array.prototype.splice

# 42. 整数对最小和

注意点的说明是什么意思？没看到答案代码里有体现。提到可以用两种解法。

1. 双重 for 循环
2. 最小堆：二叉堆本质上是一种完全二叉树，最小堆的任何一个父节点的值，都小于或等于它左、右孩子节点的值。

# 43. 乱序整数序列两数之和绝对值最小

同 1-121

# 44. 快递运输

这题，只需要考虑重量，我理解，是不是按照重量升序排列，再从头计算快递重量之和，达到刚好小于等于载重量时，就是最多能装的快递数量。

需要同时考虑价值和重量两个变量时才需要动态规划？

# 45. 检查是否存在满足条件的数字组合

数组长度不大，三重循环，找到即返回结果

# 46. ABR 车路协同场景

同 1-109

# 47. 水仙花数

不复杂，看代码
优化点：答案里先把 0-9 每个数的 n 次方算出来存储在对象中，这样在后续计算时可以重复利用。

# 48. 路灯照明问题

数量级大，路灯个数很多；照明半径很大，可能出现一个路灯覆盖其他多个路灯照明半径的情况

计算照明区间，然后合并，再计算未覆盖的区间之和

区间合并，一般：

- 先按照起始位置升序
- 再按照结束位置降序

这样当两个区间起始位置相同时，前一个区间会覆盖后一个，可以直接将后一个与前一个合并

原始：[-50, 50] [30, 170] [30, 370]

排序：[-50, 50] [30, 370] [30, 170]

合并：[-50, 370]

# 49. 构成正方形的数量

思路：

1. 对于正方形来说，确定了两个点的坐标。就能够得到另外两点的坐标。会形成两个正方形。
2. 通过画图得知两种情况下已知两个点的坐标。可以计算出另外两点的坐标。
3. 对于给定点的坐标两个点。通过公式得出另外两个点的坐标。在所有点中找到是否存在可能的两点。若存在则正方形的数量加一。
4. 由于每条边都被重复计算了，最终正方形的数量需要除以 4。

对于数据的处理，由于需要判断算出来的坐标在不在剩下的坐标中，因此保留了字符串的坐标形式，每次循环开始时处理一次字符串获取坐标数字。

# 50. 约瑟夫问题

## 思路

将 input_array 当做双端队列，从队头取出元素，判断此时计数是否为 m：

- 若是，则将取出的元素加入 output_arr，并将取出的元素的值赋值给 m，然后 len--，计数重置为 1
- 若不是，则将取出的元素放回 input_array 的队尾，仅计数++

问题：
基于数组的话，每次头部元素出队，剩下的数组元素都前移一位，复杂度 O(n)，影响性能。

## 优化解法

本题都是插入和删除操作，所以数据结构使用循环链表更合适。

- 循环链表本身就是环形结构，`head.prev = tail` `tail.next = head`。
- 链表删除节点复杂度为 O(1)

js 无链表结构，需要自行构造

1. 类 Node 用于构造节点，值 val，prev 指向上一个节点，next 指向下一个节点
2. 类 CircularLinkedList 用于构造循环链表
   - append 方法用于给链表添加 Node 元素
   - init 方法传入一个数组，内部调用 append 方法，返回一个循环链表
   - `new CircularLinkedList()`构建循环链表对象 list 后，调用 init 方法，传入数组初始化链表
   - list 有三个属性，size 表示链表长度，head 指针指向链表头部，tail 指针指向链表尾部
   - 构造链表时，第一个元素，head 和 tail 指针都指向当前元素
   - 继续添加元素，此时 tail 指向的就是当前新添加元素的上一个，那么先确定 tail 和当前元素的关系，然后更新 tail 指向
   - 循环链表还需要再增加首尾元素的指向关系。

解题思路：

1. 通过数组构建循环链表 list
2. 新建 current 指针，初始时指向 list.head
3. 如果计数等于 m，将当前元素从链表中删除：
   - 获取当前元素的上一个和下一个元素，让这两个元素建立联系
   - 把当前元素的 prev 和 next 指针指向 null
   - list.size--
   - 删除后，current 指向下一个元素
4. 如果计数不等于 m，计数++，current 指向下一个元素

利用循环链表这种数据结构，学会如何在链表中删除元素

# 51. 靠谱的车

利用**九进制**，解题思路很有意思，很受启发

1. 每一位上大于 4 的数字，由于 4 被跳过，所以实际数字需要-1
2. 少了一位数，所以计费表实际上是九进制，逢九进一
3. 先将每一位还原成正确的九进制数字，然后就是九进制转十进制

# 52. 数字涂色

# 53. 勾股数元祖

求勾股数。先算出所有数的平方放到一个数组中。然后进行双重循环。判断 a^2+b^2 结果是否在数组中。

定义一个公共方法。用于返回两个数是否互质。判断互质的方法是辗转相除法 gcd(a,b) = gcd(b,a mod b)。

# 55. 表达式括号匹配

1. 用正则去掉非括号的字符。
2. 用栈结构判断括号是否成对。

```js
const str = "(1+(2+3)*(3+(8+0))+1-2)";
const s = str.replace(/[^\(\)]/g, "");
console.log(str);
console.log(s); // (()(()))
```

# 56. 括号匹配

类似

# 57. 最大括号深度

也是用栈实现， '({[]}())' 注意这种情况

# 58. 消消乐游戏

1. `/[^a-zA-Z]/.test('aBc1')`为 true，判断有非大小写字母
2. 利用栈结构，当前元素如果与栈顶元素相同，则栈顶元素出栈，当前元素不入栈，下一个元素入栈，继续判断。

# 59. 连续自然数之和

滑动窗口

# 2. IPv4 地址转换成整数

## 分析题目

IPv4 地址 0000 0000 0000 0000 0000 0000 0000 0000
写成十进制，是把每八位二进制数转换为了十进制 192.123.111.111

现在就是把 192.123.111.111
先转换称为二进制，也就是本来的数，去掉分隔符连接起来，就是本来的数字大小。
如果转换后的二进制数不够 8 位，需要在左侧补 0
拼接后的二进制转换为 10 进制数

写法借用了 16 进制

以 "1#0#0#0" 为例：

转换成二进制数：'00000001000000000000000000000000'

二进制转换成十进制：
parseInt('00000001000000000000000000000000', 2) => 16777216

因为`1.toString(2)`结果为 1，只有 1 位，那么就需要在左边补上 7 个 0。

这样判断就很麻烦，每个位置上都需要有 8 位，那么补齐的情况就有很多种

所以好的做法就是先把每个位置转换成对应的 16 进制数，

八个二进制位，最大值是 255，用 2 位 16 进制数就能表示了

parseInt('11111111', 2) => 255
parseInt('ff', 16) => 255

所以转换为 16 进制，左侧只需要判断一下补 1 个 0 即可。

---

总结：

IPv4 地址，是 32 位二进制数。每 8 位用一个十进制表示，就是 128.255.255.255 这种格式。

这题是要把 128.255.255.255 的分隔符去掉，转换成原始 32 位二进制数，再用十进制去表示。

如果直接做，1 转换为二进制还是 1，但是需要在左边补 0，就存在需要给八位数进行补位的情况，很麻烦。借用十六进制解决。只需要补 1 位即可。

所以好的解法是先转换成 16 进制，补 0 之后再转换成 10 进制。

考察：对于 IPv4 的了解，以及进制知识。

## Number 用法

见 test

`null == 0` true
`'' == 0` true
`undefined == 0` false

# 3.VLAN 资源池

1. 提取逻辑处理中公共的部分
2. 考虑复用数组

# 4. 求字符串中所有整数的最小和

1. 计算数字时注意考虑超大数字的情况，使用 BigInt

# 5. 求满足条件的最长子串的长度

## 要求

1. 只包含一个字母，其余是数字
2. 字母可以在子串中任意位置
3. 全部是字母或者全部是数字，返回-1；那也就是说长度不可能为 1，至少为 2

## 实现

1. 滑动窗口求解思想

左右两个指针，刚开始都在 0 位置，记录字母数量
右指针右移，判断此时是不是超过了一个字母

- 如果不超过，则右指针继续右移
- 如果超过，那么此时窗口就有 2 个字母
  - 分析：
  - 则左指针++吗？但是只++某些情况下会有问题
  - 如果左指针指向的是数字，++不会减少字母数量
- 所以**实际**需要判断

  - 如果左指针指向的是字母，则++，即可
  - 如果左指针指向的是数字，
    - 分析，是直接 left=right 位置吗，也不是
    - **实际**left 应该移动到第一个字母后面的一个位置 target，
    - 如果 target 是数字，则就是移动到 target 位置，这样就避免数字损失
    - 如果 target 是字母，那其实就是右指针的位置，

- 所以在右指针移动过程中，需要记录字母在的位置的索引，这样才能取得 target 的位置

- 还需要一个变量记录左右指针之差就是长度，最后拿最长的那个

## 待完成

答案的写法更简洁，再看看

# 7. 一种字符串压缩表示的解压

判断不合法

1. 原始压缩后字符串 str：2dff
   解压后 s1，按照正确的压缩算法压缩得到字符串 s2，
   如果 str!=s2，说明 str 不合法

2. 压缩后的字符串只有数字和小写字母，出现其他字符不合法

# 8.矩阵最大值

数量级不大，所以可以考虑暴力解法，双重 for 循环

# 9. 单词接龙

考察数组方法：splice sort at shift

剩下的单词存放在对象 prefix 中：

- 键：首字母
- 值：同一个首字母的单词存放的数组中

# 10. 找出符合要求的字符串子串

1. 数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。可以给字符串和数组去重`const arr = [...new Set(str)]`

2. sort() 方法**就地**对数组的元素进行排序，并返回对相同数组的引用。默认排序是**将元素转换为字符串**，然后**按照它们的 UTF-16 码元值升序排序**。也就是直接调用 sort 即可满足 ASCII 的值从小到大排序

# 11. 字符串加密

字符串方法：

- String 的 charCodeAt() 方法返回一个整数，表示给定索引处的 UTF-16 码元，其值介于 0 和 65535 之间。`'a'.charCodeAt()` => 97
- String.fromCharCode() 静态方法返回由指定的 UTF-16 码元序列创建的字符串。`String.fromCharCode(97)` => 'a'

把字符串转换成码元数字

# 13. 按单词下标区间翻转文章内容

1. 边界值处理，通过比较大小，得到合法的 startIndex 和 endIndex
2. 翻转操作就是前后对应的值互换，使用双指针实现

# 14. TLV 解析

1. 小端序
2. 16 进制码流字符串: 32 01 00 AE
   - 32 表示 tag 占一个字节，16 进制就是两位数
   - 01 00 表示 length，小端序，改成阅读方便的就是 00 01，也就是长度为 1 个字节
   - AE 那么紧跟着的这个字节就是 value
3. 思路：字符串转换成数组，按顺序处理
4. 答案思路：不断删除掉处理过的数组成员

# 16. 连续字母长度

1. 思路：下一个字母和上一个相同时，长度增加，不同时存储长度，注意最后一个字母的情况

# 17. 拼接 URL

1. 不管有没有/，都加上，那么至少会有两个/，再通过正则匹配替换
   `'/abc//a'.replace(/\/\/+/,'/') ` => `'/abc/a'`
2. ?? 空值合并运算符

# 18. 非严格递增连续数字序列

1. 双指针
   首先指向 0，判断是字母，都++
   判断是数字，右指针++
   判断右指针数字是否等于左指针数字，或者等于左指针数字+1

# 19. 相对开音节

1. 普通做法先反转，再用正则匹配。
2. 由于最后只需要获得符和条件的子串有多少个，所以可以把正则反转。这样减少一次的反转操作。
3. 需要匹配的子串长度为四。所以相当于有一个长度为四的滑动窗口。不断往后滑动。用正则去匹配。符合条件则结果长度加 1，联想到 tcp 协议中的滑动窗口。

# 21. 字符串序列判定

1. 双指针，两个指针 i 和 j，分别指向两个字符串 s 和 l 的开始位置。当两个指针指向的字符相同时，那么指针都++；如果指向的字符不同时，则 j++。s 字符串最后一个字符在 l 中的位置就是 j-1。
2. 学习利用双指针解决问题。

# 32. 查找接口成功率最优时间段

解法思想与答案类似，答案的解法逻辑性更好。

通过构建 dp 数组，计算出 arr 中前 i 个数字之和放入 dp[i]中（这样就被称为前缀和），之后利用`let sum = i === 0 ? dp[j] : dp[j] - dp[i - 1];`这句代码，即可得到其他范围的和。

| index | 0   | 1   | 2   | 3   | 4   |
| ----- | :-- | :-- | :-- | :-- | --- |
| arr   | 0   | 1   | 2   | 3   | 4   |
| dp    | 0   | 1   | 3   | 6   | 10  |

比如需要求 index 为 3-4 范围的和，i=3，j=4，就是 10-3=7，即`dp[j] - dp[i - 1]`。
第一个 3，是 dp 数组中的 3： 3+3=6；6+4=10 => 3+3+4=10 => 3+4 => 10-3

[前缀和 & 差分](https://oi-wiki.org/basic/prefix-sum/)

# 50. 约瑟夫问题

## 思路

将 input_array 当做双端队列，从队头取出元素，判断此时计数是否为 m：

- 若是，则将取出的元素加入 output_arr，并将取出的元素的值赋值给 m，然后 len--，计数重置为 1
- 若不是，则将取出的元素放回 input_array 的队尾，仅计数++

问题：
基于数组的话，每次头部元素出队，剩下的数组元素都前移一位，复杂度 O(n)，影响性能。

## 优化解法

本题都是插入和删除操作，所以数据结构使用循环链表更合适。

- 循环链表本身就是环形结构，`head.prev = tail` `tail.next = head`。
- 链表删除节点复杂度为 O(1)

js 无链表结构，需要自行构造

1. 类 Node 用于构造节点，值 val，prev 指向上一个节点，next 指向下一个节点
2. 类 CircularLinkedList 用于构造循环链表
   - append 方法用于给链表添加 Node 元素
   - init 方法传入一个数组，内部调用 append 方法，返回一个循环链表
   - `new CircularLinkedList()`构建循环链表对象 list 后，调用 init 方法，传入数组初始化链表
   - list 有三个属性，size 表示链表长度，head 指针指向链表头部，tail 指针指向链表尾部
   - 构造链表时，第一个元素，head 和 tail 指针都指向当前元素
   - 继续添加元素，此时 tail 指向的就是当前新添加元素的上一个，那么先确定 tail 和当前元素的关系，然后更新 tail 指向
   - 循环链表还需要再增加首尾元素的指向关系。

解题思路：

1. 通过数组构建循环链表 list
2. 新建 current 指针，初始时指向 list.head
3. 如果计数等于 m，将当前元素从链表中删除：
   - 获取当前元素的上一个和下一个元素，让这两个元素建立联系
   - 把当前元素的 prev 和 next 指针指向 null
   - list.size--
   - 删除后，current 指向下一个元素
4. 如果计数不等于 m，计数++，current 指向下一个元素

利用循环链表这种数据结构，学会如何在链表中删除元素

# 49. 构成正方形的数量 未完成

思路：

1. 对于正方形来说，确定了两个点的坐标。就能够得到另外两点的坐标。会形成两个正方形。
2. 通过画图得知两种情况下已知两个点的坐标。可以计算出另外两点的坐标。
3. 对于给定点的坐标两个点。通过公式得出另外两个点的坐标。在所有点中找到是否存在可能的两点。若存在则正方形的数量加一。
4. 由于每条边都被重复计算了，最终正方形的数量需要除以 8。

# 51. 靠谱的车

解题思路很有意思，很受启发

1. 每一位上大于 4 的数字，由于 4 被跳过，所以实际数字需要-1
2. 少了一位数，所以计费表实际上是九进制，逢九进一
3. 先将每一位还原成正确的九进制数字，然后就是九进制转十进制

# 69. 运维日志排序

正则匹配获取时分秒毫秒，统一转换成毫秒，比较大小后排序。

使用 sort 比较，相同的会保持输入顺序

# 71. 比赛

> 难点：如果得分相同，则得分高分值最多的选手排名靠前

自己思路：做出来了，但是对于上述逻辑的实现不够完善。

答案思路：将选手分数降序排序后，`join("")`为字符串数值，高分多的选手该字符串数值越大！

知识点：使用 sort 排序时，可以在函数里面写判断逻辑，针对多种判断的情况。

# 73. 磁盘容量排序

稳定排序：当容量相等时，保留原来的相对位置

**Array.prototype.sort 为稳定排序**。

# 75. 字符串排序

1. 先排序后去重，基于栈结构去重，排序后，不区分大小写的两个字符串是挨着的

# 79. 堆栈中的剩余数字

dp => dynamic programming [动态规划](https://zhuanlan.zhihu.com/p/365698607)

答案解题思路：

1. 求出数组 arr 对应的数组 dp，比如

| arr | 1   | 2   | 5   | 7   | 9   | 1   | 2   | 2   |
| --- | --- | --- | :-- | :-- | :-- | :-- | :-- | :-- |
| dp  | 1   | 3   | 8   | 15  | 24  | 25  | 27  | 29  |

dp 数组第 i 位的值 dp[i] = arr[i] + dp[i-1]，也就是 0~i-1 的元素之和

2. 用指针 i 扫描，比较 arr[i] 和 dp[i-1]的关系

- arr[i] === dp[i-1]，就是满足题目条件，0~i-1 的元素之和等于 arr[i]。把元素之和合并入 arr[i]中，即 arr[i] = 2 \* arr[i]。0~i-1 范围内的元素全部置为 0。
- arr[i] > dp[i-1]，说明前面 k~i-1 (0 <= k <=i-1) 所有元素加起来无法满足题目条件，无法合并。
- arr[i] < dp[i-1]
  - 如果能找到 k (0 < k <= i-1)，使得 k~i-1 所有元素加起来满足题目条件。k~i-1 的元素之和等于 arr[i]。把元素之和合并入 arr[i]中，即 arr[i] = 2 \* arr[i]。k~i-1 范围内的元素全部置为 0。
  - 如果找不到 k，无法合并
- 最后去掉数组中为 0 的元素，反序输出

# 81. 报数游戏

约瑟夫环问题，利用循环链表

1. 指针指向 list.head 为当前元素，初始化为 1，依次增加，到 M 位置时，删除该位置元素
2. 删除后，指针重置为 1
3. 循环上述步骤，直到链表长度小于 M

构造循环链表

1. CircularLinkedList 实例：size 链表大小 head 指针 tail 指针
2. 循环链表：head.prev = tail tail.next = prev
3. 提供 init 方法将数组初始化为链表，init 方法中通过 append 方法将每个元素变为链表节点 Node
4. 链表节点 Node 实例：value 内容 prev 指向上一个元素 next 指针指向下一个元素

# 83. 工号不够用了怎么办？

Math 的几个方法：`Math.max(1, Math.ceil(Math.log10(x / Math.pow(16 / y))));`

# 88. 最小交换次数

## 题目

有一个数组 arr。给出数字 k。请输出数组中所有小于 k 的整数组合到一起的最少交换次数。组合到一起是指满足条件的数字相邻，不要求相邻后在数组中的位置。

数据范围：-100 <= k <= 100

例如：arr = [1,3,1,4,0] ; k = 2。最少交换次数：1。0 和 3 交换。

## 思路

滑动窗口求解。

1. 首先统计出数组中小于 k 的整数的数量 count。就是滑动窗口的大小。注意滑动起点的起始范围：[0, arr.length-count]
2. 统计滑动窗口中大于 k 的整数的数量。就是需要交换的次数。
3. 滑动窗口右移，比较得到最小交换次数。

普通做法双重循环算法复杂度为 O(n^2)

## 优化点

当滑动窗口移动一格时，中间的元素已经计算过了。此时只需要将减少的元素和增加的元素与 k 进行比较。

- 如果都小于或者都大于 k，那么交换次数相同。
- 如果减少的元素小于等于 k，增加的元素大于等于 k，那么交换次数增加。
- 如果减少的元素大于等于 k，增加的元素小于等于 k，那么交换次数减少。

# 95. 数大雁

1. 叫声需要连续并且完整，记录所有叫声区间['q 索引','k 索引']，多少区间表示有多少声叫声
2. 题目要求求得最少有几只大雁，区间有交集的部分，表示有大雁同时发声，区间不相交，可以是同一只大雁重复发出声音。所以交集数量加一也就对应了最少大雁的数量
3. 每一个区间都需要与后面的算交集，取最大交集数

- 'quackquack'，[0,4] [5,9]两个区间，交集数为 0，最少大雁为 1，即 1 个大雁叫了两声。
- 'quackquacqkuack'，[0,4] [5,10] [9,14] 两个区间，交集数为 1，最少大雁为 2，[0,4]，第一个区间与后面的交集为 0；第二个区间与后面的交集数为 1 后面两个区间有交集，则至少是 1+1= 2 只大雁同时叫了。

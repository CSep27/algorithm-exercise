# 2. IPv4 地址转换成整数

## 分析题目

IPv4 地址 0000 0000 0000 0000 0000 0000 0000 0000
写成十进制，是把每八位二进制数转换为了十进制 192.123.111.111

现在就是把 192.123.111.111
先转换称为二进制，也就是本来的数，去掉分隔符连接起来，就是本来的数字大小。
如果转换后的二进制数不够 8 位，需要在左侧补 0
拼接后的二进制转换为 10 进制数

写法借用了 16 进制

以 "1#0#0#0" 为例：

转换成二进制数：'00000001000000000000000000000000'

二进制转换成十进制：
parseInt('00000001000000000000000000000000', 2) => 16777216

因为`1.toString(2)`结果为 1，只有 1 位，那么就需要在左边补上 7 个 0。

这样判断就很麻烦，每个位置上都需要有 8 位，那么补齐的情况就有很多种

所以好的做法就是先把每个位置转换成对应的 16 进制数，

八个二进制位，最大值是 255，用 2 位 16 进制数就能表示了

parseInt('11111111', 2) => 255
parseInt('ff', 16) => 255

所以转换为 16 进制，左侧只需要判断一下补 1 个 0 即可。

---

总结：

IPv4 地址，是 32 位二进制数。每 8 位用一个十进制表示，就是 128.255.255.255 这种格式。

这题是要把 128.255.255.255 的分隔符去掉，转换成原始 32 位二进制数，再用十进制去表示。

如果直接做，1 转换为二进制还是 1，但是需要在左边补 0，就存在需要给八位数进行补位的情况，很麻烦。借用十六进制解决。只需要补 1 位即可。

所以好的解法是先转换成 16 进制，补 0 之后再转换成 10 进制。

考察：对于 IPv4 的了解，以及进制知识。

## Number 用法

见 test

`null == 0` true
`'' == 0` true
`undefined == 0` false

# 3.VLAN 资源池

1. 提取逻辑处理中公共的部分
2. 考虑复用数组

# 4. 求字符串中所有整数的最小和

1. 计算数字时注意考虑超大数字的情况，使用 BigInt

# 5. 求满足条件的最长子串的长度

## 要求

1. 只包含一个字母，其余是数字
2. 字母可以在子串中任意位置
3. 全部是字母或者全部是数字，返回-1；那也就是说长度不可能为 1，至少为 2

## 实现

1. 滑动窗口求解思想

左右两个指针，刚开始都在 0 位置，记录字母数量
右指针右移，判断此时是不是超过了一个字母

- 如果不超过，则右指针继续右移
- 如果超过，那么此时窗口就有 2 个字母
  - 分析：
  - 则左指针++吗？但是只++某些情况下会有问题
  - 如果左指针指向的是数字，++不会减少字母数量
- 所以**实际**需要判断

  - 如果左指针指向的是字母，则++，即可
  - 如果左指针指向的是数字，
    - 分析，是直接 left=right 位置吗，也不是
    - **实际**left 应该移动到第一个字母后面的一个位置 target，
    - 如果 target 是数字，则就是移动到 target 位置，这样就避免数字损失
    - 如果 target 是字母，那其实就是右指针的位置，

- 所以在右指针移动过程中，需要记录字母在的位置的索引，这样才能取得 target 的位置

- 还需要一个变量记录左右指针之差就是长度，最后拿最长的那个

## 待完成

答案的写法更简洁，再看看

# 7. 一种字符串压缩表示的解压

判断不合法

1. 原始压缩后字符串 str：2dff
   解压后 s1，按照正确的压缩算法压缩得到字符串 s2，
   如果 str!=s2，说明 str 不合法

2. 压缩后的字符串只有数字和小写字母，出现其他字符不合法

# 8.矩阵最大值

数量级不大，所以可以考虑暴力解法，双重 for 循环

# 9. 单词接龙

考察数组方法：splice sort at shift

剩下的单词存放在对象 prefix 中：

- 键：首字母
- 值：同一个首字母的单词存放的数组中

# 10. 找出符合要求的字符串子串

1. 数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。可以给字符串和数组去重`const arr = [...new Set(str)]`

2. sort() 方法**就地**对数组的元素进行排序，并返回对相同数组的引用。默认排序是**将元素转换为字符串**，然后**按照它们的 UTF-16 码元值升序排序**。也就是直接调用 sort 即可满足 ASCII 的值从小到大排序

# 11. 字符串加密

字符串方法：

- String 的 charCodeAt() 方法返回一个整数，表示给定索引处的 UTF-16 码元，其值介于 0 和 65535 之间。`'a'.charCodeAt()` => 97
- String.fromCharCode() 静态方法返回由指定的 UTF-16 码元序列创建的字符串。`String.fromCharCode(97)` => 'a'

把字符串转换成码元数字

# 13. 按单词下标区间翻转文章内容

1. 边界值处理，通过比较大小，得到合法的 startIndex 和 endIndex
2. 翻转操作就是前后对应的值互换，使用双指针实现

# 14. TLV 解析

1. 小端序
2. 16 进制码流字符串: 32 01 00 AE
   - 32 表示 tag 占一个字节，16 进制就是两位数
   - 01 00 表示 length，小端序，改成阅读方便的就是 00 01，也就是长度为 1 个字节
   - AE 那么紧跟着的这个字节就是 value
3. 思路：字符串转换成数组，按顺序处理
4. 答案思路：不断删除掉处理过的数组成员

# 16. 连续字母长度

1. 思路：下一个字母和上一个相同时，长度增加，不同时存储长度，注意最后一个字母的情况

# 17. 拼接 URL

1. 不管有没有/，都加上，那么至少会有两个/，再通过正则匹配替换
   `'/abc//a'.replace(/\/\/+/,'/') ` => `'/abc/a'`
2. ?? 空值合并运算符

# 18. 非严格递增连续数字序列

1. 双指针
   首先指向 0，判断是字母，都++
   判断是数字，右指针++
   判断右指针数字是否等于左指针数字，或者等于左指针数字+1

# 19. 相对开音节

1. 普通做法先反转，再用正则匹配。
2. 由于最后只需要获得符和条件的子串有多少个，所以可以把正则反转。这样减少一次的反转操作。
3. 需要匹配的子串长度为四。所以相当于有一个长度为四的滑动窗口。不断往后滑动。用正则去匹配。符合条件则结果长度加 1，联想到 tcp 协议中的滑动窗口。

# 21. 字符串序列判定

1. 双指针，两个指针 i 和 j，分别指向两个字符串 s 和 l 的开始位置。当两个指针指向的字符相同时，那么指针都++；如果指向的字符不同时，则 j++。s 字符串最后一个字符在 l 中的位置就是 j-1。
2. 学习利用双指针解决问题。

# 50. 约瑟夫问题

## 思路

将 input_array 当做双端队列，从队头取出元素，判断此时计数是否为 m：

- 若是，则将取出的元素加入 output_arr，并将取出的元素的值赋值给 m，然后 len--，计数重置为 1
- 若不是，则将取出的元素放回 input_array 的队尾，仅计数++

问题：
基于数组的话，每次头部元素出队，剩下的数组元素都前移一位，复杂度 O(n)，影响性能。

## 优化解法

本题都是插入和删除操作，所以数据结构使用循环链表更合适。

- 循环链表本身就是环形结构，`head.prev = tail` `tail.next = head`。
- 链表删除节点复杂度为 O(1)

js 无链表结构，需要自行构造

1. 类 Node 用于构造节点，值 val，prev 指向上一个节点，next 指向下一个节点
2. 类 CircularLinkedList 用于构造循环链表
   - append 方法用于给链表添加 Node 元素
   - init 方法传入一个数组，内部调用 append 方法，返回一个循环链表
   - `new CircularLinkedList()`构建循环链表对象 list 后，调用 init 方法，传入数组初始化链表
   - list 有三个属性，size 表示链表长度，head 指针指向链表头部，tail 指针指向链表尾部
   - 构造链表时，第一个元素，head 和 tail 指针都指向当前元素
   - 继续添加元素，此时 tail 指向的就是当前新添加元素的上一个，那么先确定 tail 和当前元素的关系，然后更新 tail 指向
   - 循环链表还需要再增加首尾元素的指向关系。

解题思路：

1. 通过数组构建循环链表 list
2. 新建 current 指针，初始时指向 list.head
3. 如果计数等于 m，将当前元素从链表中删除：
   - 获取当前元素的上一个和下一个元素，让这两个元素建立联系
   - 把当前元素的 prev 和 next 指针指向 null
   - list.size--
   - 删除后，current 指向下一个元素
4. 如果计数不等于 m，计数++，current 指向下一个元素

利用循环链表这种数据结构，学会如何在链表中删除元素

# 49. 构成正方形的数量 未完成

思路：

1. 对于正方形来说，确定了两个点的坐标。就能够得到另外两点的坐标。会形成两个正方形。
2. 通过画图得知两种情况下已知两个点的坐标。可以计算出另外两点的坐标。
3. 对于给定点的坐标两个点。通过公式得出另外两个点的坐标。在所有点中找到是否存在可能的两点。若存在则正方形的数量加一。
4. 由于每条边都被重复计算了，最终正方形的数量需要除以 8。

# 51. 靠谱的车

解题思路很有意思，很受启发

1. 每一位上大于 4 的数字，由于 4 被跳过，所以实际数字需要-1
2. 少了一位数，所以计费表实际上是九进制，逢九进一
3. 先将每一位还原成正确的九进制数字，然后就是九进制转十进制

# 69. 运维日志排序

正则匹配获取时分秒毫秒，统一转换成毫秒，比较大小后排序。

使用 sort 比较，相同的会保持输入顺序

# 71. 比赛

> 难点：如果得分相同，则得分高分值最多的选手排名靠前

自己思路：做出来了，但是对于上述逻辑的实现不够完善。

答案思路：将选手分数降序排序后，`join("")`为字符串数值，高分多的选手该字符串数值越大！

知识点：使用 sort 排序时，可以在函数里面写判断逻辑，针对多种判断的情况。

# 73. 磁盘容量排序

稳定排序：当容量相等时，保留原来的相对位置

**Array.prototype.sort 为稳定排序**。

# 75. 字符串排序

1. 先排序后去重，基于栈结构去重，排序后，不区分大小写的两个字符串是挨着的

# 79. 堆栈中的剩余数字

dp => dynamic programming [动态规划](https://zhuanlan.zhihu.com/p/365698607)

答案解题思路：

1. 求出数组 arr 对应的数组 dp，比如

| arr | 1   | 2   | 5   | 7   | 9   | 1   | 2   | 2   |
| --- | --- | --- | :-- | :-- | :-- | :-- | :-- | :-- |
| dp  | 1   | 3   | 8   | 15  | 24  | 25  | 27  | 29  |

dp 数组第 i 位的值 dp[i] = arr[i] + dp[i-1]，也就是 0~i-1 的元素之和

2. 用指针 i 扫描，比较 arr[i] 和 dp[i-1]的关系

- arr[i] === dp[i-1]，就是满足题目条件，0~i-1 的元素之和等于 arr[i]。把元素之和合并入 arr[i]中，即 arr[i] = 2 \* arr[i]。0~i-1 范围内的元素全部置为 0。
- arr[i] > dp[i-1]，说明前面 k~i-1 (0 <= k <=i-1) 所有元素加起来无法满足题目条件，无法合并。
- arr[i] < dp[i-1]
  - 如果能找到 k (0 < k <= i-1)，使得 k~i-1 所有元素加起来满足题目条件。k~i-1 的元素之和等于 arr[i]。把元素之和合并入 arr[i]中，即 arr[i] = 2 \* arr[i]。k~i-1 范围内的元素全部置为 0。
  - 如果找不到 k，无法合并
- 最后去掉数组中为 0 的元素，反序输出

# 88. 最小交换次数

## 题目

有一个数组 arr。给出数字 k。请输出数组中所有小于 k 的整数组合到一起的最少交换次数。组合到一起是指满足条件的数字相邻，不要求相邻后在数组中的位置。

数据范围：-100 <= k <= 100

例如：arr = [1,3,1,4,0] ; k = 2。最少交换次数：1。0 和 3 交换。

## 思路

滑动窗口求解。

1. 首先统计出数组中小于 k 的整数的数量 count。就是滑动窗口的大小。注意滑动起点的起始范围：[0, arr.length-count]
2. 统计滑动窗口中大于 k 的整数的数量。就是需要交换的次数。
3. 滑动窗口右移，比较得到最小交换次数。

普通做法双重循环算法复杂度为 O(n^2)

## 优化点

当滑动窗口移动一格时，中间的元素已经计算过了。此时只需要将减少的元素和增加的元素与 k 进行比较。

- 如果都小于或者都大于 k，那么交换次数相同。
- 如果减少的元素小于等于 k，增加的元素大于等于 k，那么交换次数增加。
- 如果减少的元素大于等于 k，增加的元素小于等于 k，那么交换次数减少。

# 95. 数大雁

1. 叫声需要连续并且完整，记录所有叫声区间['q 索引','k 索引']，多少区间表示有多少声叫声
2. 题目要求求得最少有几只大雁，区间有交集的部分，表示有大雁同时发声，区间不相交，可以是同一只大雁重复发出声音。所以交集数量加一也就对应了最少大雁的数量
3. 每一个区间都需要与后面的算交集，取最大交集数

- 'quackquack'，[0,4] [5,9]两个区间，交集数为 0，最少大雁为 1，即 1 个大雁叫了两声。
- 'quackquacqkuack'，[0,4] [5,10] [9,14] 两个区间，交集数为 1，最少大雁为 2，[0,4]，第一个区间与后面的交集为 0；第二个区间与后面的交集数为 1 后面两个区间有交集，则至少是 1+1= 2 只大雁同时叫了。

# 103. 第 k 个的排列

答案思路：

n=3
arr=[1,2,3]
123 132 213 231 312 321 共 3!=6 个数
k=3

1. 6（n!）个数，一共 3（也就是 n）组，每组 2（(n-1)!）个数，对于第 3（k）个数，可以算出在第 2 组（Math.ceil(k/(n-1)!)）。开头数字为 2，也就是对应 arr 中的 2。
2. 数字 2 在 arr 数组下标为 1，通用计算获取数为 index = Math.floor((k-1)/(n-1)!)。（k-1 是先把 k 转换成和下标一致），arr[index]就是第一个数字
3. 问题转化为在 213 231 两个数中，找出 newK=1 的对应的数字
4. 需要在 213 231 中找，k 不再是 3，而是 1。newK 的转化公式：newK = k % (n-1)!，当 newK 算出来为 0 时，整除了，表示是最后一个数，也就是(n-1)!，所以最终 newK = k % (n-1)! === 0 ? (n-1)! : k % (n-1)!（此时 n 还是 3）
5. arr 中剩下[1,3]两个数，arr 更新，n 更新为 2 组，每组 1 个数
6. 可以看出此时就是需要的数字排列，所以结束条件为 k===1。此时数组排列顺序，就是
7. 如果 k !== 1，再根据更新后的 k 和 n 重复第二步，得到新的 index，也就获取到了下一个数字。直到触发 k===1 的结束条件

# 105. 找车位

自己思路：

1. 左右指针，如果都指向 1，中间值间距为 `Math.floor((right - left) / 2)`。再判断更新最大长度
2. 边缘情况，左 0 右 1，或者左 1 右 0，间距为 right - left。同样判断更新最大长度

答案思路：

1. 用 1 去 split 字符串，得到全部为 0 的子串
2. 判断边缘情况就是子串长度，非边缘情况就是 `Math.ceil(subStr.length/2)`

整体都差不多

# 108. 流水线

1. 将时长 t 按照升序排序
1. 如果 n <= m，返回时间 t 中最长的即可
1. 如果 n>m，取最长时长所在的流水线上，所有时长相加。

# 111. 统计射击比赛成绩

简单排序问题

# 112. 分苹果

没看懂题目

1. **二进制不进位就是按位异或**（相同为 0，不同为 1）：a ^ b
2. 十进制进位就是正常加法
3. 满足 A 的分法的话，所有数异或结果为 0（因为最终两个相同的数异或结果为 0，计算后的两个数相同也就意味着按照 A 的分发平分了）
4. B 获得重量最大，只需要把所有苹果中重量最小的给 A，剩下的给 B

# 113. 最大股票收益

前提：手上只能保留一只股票

股票买入要花钱，卖出赚钱，所以最赚钱是低买高卖。

贪心思维，买涨不买跌。

# 114. 单词重量

保留两位小数并四舍五入：Number.prototype.toFix(位数)

# 115. 金字塔，BOSS 的收入

自己的解法，增加 parent 引用父级代理商
答案解法，利用二维数组，更简单

# 122. 整数编码

- 原码 数字本身
- 反码 原码除符号位按位取反
- 补码 反码加一
- 正数的原码、反码、补码都相同，都等于原码；负数的反码等于除符号位按位取反，负数的补码等于反码末位加 1。

本题都是非负整数，补码与原码相同。

小端序，低位放在低地址。

举例：1000
二进制 0011 1110 1000，至少需要两个字节。
第一个字节，第一位放 1，表示还有字节，剩下放七位 110 1000，组合起来就是 1110 1000 ，转换成 16 进制 E8。
第二个字节，第一位放 0，表示接下来没有字节了，剩下放七位 000 0111，组合起来就是 0000 0111 ，转换成 16 进制 07。
最终结果为 E807

思路：

num.toString(2) 转换成二进制，长度除以 7，再加一，就是需要占多少个字节。

str.slice()方法从尾部截取数字，参数可以是负数，包括 start 不包括 end

# 120. 德州扑克

1. 大小和花色分开存储

2. 四条（四张牌相同，一张牌不同）的判断，用 new Set()去重，去重后只有两张牌。取其中一张判断在 nums 中有几个，若为 1 个或 4 个，可以判定位 4 条。
